<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alan&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nullhint.org/"/>
  <updated>2018-10-17T14:38:32.145Z</updated>
  <id>http://nullhint.org/</id>
  
  <author>
    <name>Xibo Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HotSpot虚拟机垃圾收集器</title>
    <link href="http://nullhint.org/2018/10/17/JVM_GarbageCollectors/"/>
    <id>http://nullhint.org/2018/10/17/JVM_GarbageCollectors/</id>
    <published>2018-10-17T14:50:00.000Z</published>
    <updated>2018-10-17T14:38:32.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java是自动回收内存的，垃圾收集算法是内存回收的方法论，而垃圾收集器（Garbage Collector）是内存回收的具体实现。</p><a id="more"></a><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><strong>标记</strong>需要回收的对象，然后<strong>清除</strong>掉。</p><p>该算法存在以下<strong>不足</strong>：</p><ul><li>效率问题，标记和清除的效率都不高。</li><li>空间问题，会产生空间碎片。</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>把空间分成大小相等的两块，每次只使用其中的一块。当一块内存用完了，就把存活的对象<strong>复制</strong>到另一块内存空间上面。</p><p>该算法主要用于回收新生代，因为新生代的对象存活率不高。并且在HotSpot虚拟机中也不是按1:1划分内存空间，而是按8:1:1划分为一个<strong>Eden</strong>和两个<strong>Survivor</strong>空间（当Survivor空间不足时，需依赖老年代进行分配担保）。每次使用Eden和一个Survivor，当回收时，将Eden和Survivor的存活对象一次性复制到另一个Survivor中。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记过程与标记-清除算法的“标记”一样，但是后续步骤不是清除对象，而是把存活的对象移到一端。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据对象存活周期的不同将内存划分为<strong>新生代</strong>和<strong>老年代</strong>，进而根据各个年代的特点采用适当的收集算法。</p><h2 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h2><p>分析垃圾收集器，可从以下四个方面考虑：</p><ol><li>单线程还是多线程。</li><li>作用在新生代还是老年代。</li><li>使用什么收集算法。</li><li>可以配合使用的垃圾收集器有哪些。</li></ol><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><ul><li>使用<strong>单线程</strong>进行垃圾收集。</li><li>使用在<strong>新生代</strong>，采用<strong>复制算法</strong>。</li><li>简单而高效，因为没有线程间的交互。</li></ul><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><ul><li>是Serial 收集器的<strong>多线程</strong>版本。</li><li>使用在<strong>新生代</strong>，采用<strong>复制算法</strong>。</li><li>能更有效地利用多核或多线程硬件，主要运行在Server模式。</li></ul><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><ul><li>跟ParNew 收集器很类似，也是多线程收集器，但关注点在<strong>吞吐量优先</strong>。</li><li>使用在<strong>新生代</strong>，采用<strong>复制算法</strong>。</li></ul><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><ul><li>Serial 收集器的<strong>老年代</strong>版本，使用<strong>标记-整理算法</strong>。</li></ul><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><ul><li>Parallel Scavenge收集器的<strong>老年代</strong>版本，使用<strong>标记-整理算法</strong>。</li></ul><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><ul><li><strong>关注点</strong>：获取最短的回收停顿时间。</li><li>使用在<strong>老年代</strong>，采用<strong>标记-清除算法</strong>。</li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>G1是一款面向服务端的垃圾收集器，它将整个Java堆划分为多个大小相等的独立区域（Region），优先回收价值最大的Region（这也是Garbage-First名称的由来）。</p><h2 id="怎么选择垃圾收集器"><a href="#怎么选择垃圾收集器" class="headerlink" title="怎么选择垃圾收集器"></a>怎么选择垃圾收集器</h2><p>可以优先调整堆的大小来改善性能，如果不能满足需求，则参考以下原则选择垃圾收集器：</p><ul><li>如果应用数据集比较小（大概100M），使用<strong>Serial 收集器</strong>。</li><li>如果应用运行在单核机器上，并且没有停顿时间的需求，也使用<strong>Serial 收集器</strong>。</li><li>如果优先考虑机器吞吐量，并且没有停顿时间的需求，使用<strong>Parallel 收集器</strong>。</li><li>如果响应时间比吞吐量更重要，使用<strong>CMS或G1收集器</strong>。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《深入理解Java虚拟机》</li><li><a href="https://docs.oracle.com/javase/9/gctuning/available-collectors.htm#JSGCT-GUID-F215A508-9E58-40B4-90A5-74E29BF3BD3C" target="_blank" rel="external">https://docs.oracle.com/javase/9/gctuning/available-collectors.htm#JSGCT-GUID-F215A508-9E58-40B4-90A5-74E29BF3BD3C</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java是自动回收内存的，垃圾收集算法是内存回收的方法论，而垃圾收集器（Garbage Collector）是内存回收的具体实现。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://nullhint.org/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring ApplicationEvent用法</title>
    <link href="http://nullhint.org/2018/10/05/Spring_ApplicationEvent/"/>
    <id>http://nullhint.org/2018/10/05/Spring_ApplicationEvent/</id>
    <published>2018-10-05T13:20:00.000Z</published>
    <updated>2018-10-05T13:09:47.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring的事件机制是观察者设计模式的实现。Spring使用<code>ApplicationEvent</code>作为不同<code>bean</code>之间通信的媒介。</p><p><code>bean</code>可以作为发布者，发布特定的<code>event</code>，而其他的<code>bean</code>可以通过实现<code>ApplicationListener</code>，对特定的<code>event</code>进行订阅，当发布者发布消息时，观察者就可以收到消息。</p><p>Spring事件机制的好处是发布者与订阅者解耦，相互间不需要知道对方的实现细节。</p><a id="more"></a><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><ul><li><p>定义事件类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String message;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 构造函数。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> source  用来标识事件源（非空）</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> message 要传递的字符串消息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source, String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(source);</div><div class="line">        <span class="keyword">this</span>.setMessage(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>定义监听类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Async</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"从DemoEvent接收到如下消息："</span> + event.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>定义发布类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">published</span><span class="params">()</span> </span>&#123;</div><div class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>, <span class="string">"Hello World"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(<span class="string">"org.nullhint.applicationevent"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(TestMain.class);</div><div class="line">        DemoPublisher publisher = context.getBean(DemoPublisher.class);</div><div class="line">        publisher.published();</div><div class="line">        context.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.javarticles.com/2015/05/spring-applicationevent-example.html" target="_blank" rel="external">http://www.javarticles.com/2015/05/spring-applicationevent-example.html</a></li><li><a href="https://blog.csdn.net/sinat_33625560/article/details/78605367" target="_blank" rel="external">https://blog.csdn.net/sinat_33625560/article/details/78605367</a></li><li><a href="https://www.baeldung.com/spring-events" target="_blank" rel="external">https://www.baeldung.com/spring-events</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Spring的事件机制是观察者设计模式的实现。Spring使用&lt;code&gt;ApplicationEvent&lt;/code&gt;作为不同&lt;code&gt;bean&lt;/code&gt;之间通信的媒介。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bean&lt;/code&gt;可以作为发布者，发布特定的&lt;code&gt;event&lt;/code&gt;，而其他的&lt;code&gt;bean&lt;/code&gt;可以通过实现&lt;code&gt;ApplicationListener&lt;/code&gt;，对特定的&lt;code&gt;event&lt;/code&gt;进行订阅，当发布者发布消息时，观察者就可以收到消息。&lt;/p&gt;
&lt;p&gt;Spring事件机制的好处是发布者与订阅者解耦，相互间不需要知道对方的实现细节。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://nullhint.org/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Session与Cookie总结</title>
    <link href="http://nullhint.org/2018/09/14/SessionCookie/"/>
    <id>http://nullhint.org/2018/09/14/SessionCookie/</id>
    <published>2018-09-14T12:45:00.000Z</published>
    <updated>2018-09-14T12:46:01.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Session与Cookie分别是什么？"><a href="#Session与Cookie分别是什么？" class="headerlink" title="Session与Cookie分别是什么？"></a>Session与Cookie分别是什么？</h2><ul><li><strong>Cookie</strong>是HTTP头中的一个字段，浏览器对其有大小和数量限制。</li><li><strong>Session</strong>解决了Cookie在浏览器与服务器来回传输的问题，客户端只保存Session ID，数据放在服务端。</li><li>存的都是<strong>键值对</strong>。</li></ul><h2 id="Session与Cookie的作用"><a href="#Session与Cookie的作用" class="headerlink" title="Session与Cookie的作用"></a>Session与Cookie的作用</h2><p>保持访问用户与后端服务器的交互状态。（因为HTTP是一种无状态协议）</p><a id="more"></a><h2 id="Session与Cookie的区别和联系是什么？"><a href="#Session与Cookie的区别和联系是什么？" class="headerlink" title="Session与Cookie的区别和联系是什么？"></a>Session与Cookie的区别和联系是什么？</h2><ol><li>Cookie数据存放在客户端浏览器上，Session数据放在服务器上。</li><li>Cookie不是很安全，可以修改。</li><li>Cookie有大小和数量限制。</li><li>多台服务器共享Session会存在问题。</li></ol><h2 id="Session与Cookie的实现方式"><a href="#Session与Cookie的实现方式" class="headerlink" title="Session与Cookie的实现方式"></a>Session与Cookie的实现方式</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ol><li>服务端创建Cookie。</li><li>客户端返回Cookie。<br>根据请求的<strong>URL路径</strong>，将符合条件的Cookie放在Request请求头中传回给服务端，服务端通过<code>request.getCookies()</code>获取。（注：一个域名下的Cookie不能被另一个域名访问）</li></ol><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul><li><p>服务端获取SessionID的三种方式：</p><ol><li>SessionID附带在URL路径参数。</li><li>通过Cookie传递SessionID。</li><li>基于SSL。</li></ol></li><li><p>Session如何工作</p><ol><li>通过<code>request.getSession()</code>获取对应ID的Session，如果该Session不存在或已过期，则创建新的Session。</li><li>Servlet容器重启或开闭时，所有<code>StandardSession</code>对象持久化到一个以<code>“SESSIONS.ser”</code>为文件名的文件中。</li><li>Tomcat中Session对象有效时间为60秒。</li></ol></li></ul><h2 id="分布式Session管理的几种实现方式"><a href="#分布式Session管理的几种实现方式" class="headerlink" title="分布式Session管理的几种实现方式"></a>分布式Session管理的几种实现方式</h2><ol><li>Session复制。</li><li>Session绑定（会话粘滞）。</li><li>利用Cookie记录Session。</li><li>Session服务器。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="解决表单重复提交问题"><a href="#解决表单重复提交问题" class="headerlink" title="解决表单重复提交问题"></a>解决表单重复提交问题</h3><ul><li><p><strong>出现原因</strong><br>网速慢，频繁点击提交按钮；手动刷新等。</p></li><li><p><strong>解决方案</strong></p><ol><li>在<strong>请求表单页面</strong>时，由服务器端生成唯一token（令牌），存储到用户Session中，并设置到页面的一个Hidden域中。</li><li><strong>提交表单</strong>时，用Hidden表单域中的token与Session的token做比较。如果相等说明是首次提交，就处理本次请求，然后<strong>将Session中的token移除</strong>；不相等（包括Session不存在token）说明是是重复提交，不做处理。<blockquote><p>注：<strong>请求表单</strong>与<strong>提交表单</strong>是两个动作。</p></blockquote></li></ol></li></ul><h3 id="多终端登录（如扫码登录等）的实现"><a href="#多终端登录（如扫码登录等）的实现" class="headerlink" title="多终端登录（如扫码登录等）的实现"></a>多终端登录（如扫码登录等）的实现</h3><ol><li>扫描PC网页上的二维码；</li><li>用手机上的登录用户去服务端设置标识位；</li><li>PC端网页不断请求服务端标识位是否已经设置；</li><li>标识位设置后网页跳转到已登录页面。</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>《深入分析Java Web技术内幕》</li><li>《大型网站技术架构》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Session与Cookie分别是什么？&quot;&gt;&lt;a href=&quot;#Session与Cookie分别是什么？&quot; class=&quot;headerlink&quot; title=&quot;Session与Cookie分别是什么？&quot;&gt;&lt;/a&gt;Session与Cookie分别是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cookie&lt;/strong&gt;是HTTP头中的一个字段，浏览器对其有大小和数量限制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Session&lt;/strong&gt;解决了Cookie在浏览器与服务器来回传输的问题，客户端只保存Session ID，数据放在服务端。&lt;/li&gt;
&lt;li&gt;存的都是&lt;strong&gt;键值对&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Session与Cookie的作用&quot;&gt;&lt;a href=&quot;#Session与Cookie的作用&quot; class=&quot;headerlink&quot; title=&quot;Session与Cookie的作用&quot;&gt;&lt;/a&gt;Session与Cookie的作用&lt;/h2&gt;&lt;p&gt;保持访问用户与后端服务器的交互状态。（因为HTTP是一种无状态协议）&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://nullhint.org/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring的事务传播性与隔离级别</title>
    <link href="http://nullhint.org/2018/09/04/SpringTransactionPropagation/"/>
    <id>http://nullhint.org/2018/09/04/SpringTransactionPropagation/</id>
    <published>2018-09-04T01:00:00.000Z</published>
    <updated>2018-09-04T00:58:50.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>事务最重要的两个特性，是事务的<strong>传播级别</strong>和数据<strong>隔离级别</strong>。</p><blockquote><p><strong>传播级别</strong>定义的是事务的控制范围。<br><strong>隔离级别</strong>定义的是事务在数据库读写方面的控制范围。</p></blockquote></li><li><p>都定义在Spring的<code>TransactionDefinition</code>接口中，传播性有<strong>七种</strong>，隔离级别有<strong>五种</strong>。</p><blockquote><p>（Spring3、Spring4数量都是如此）</p></blockquote></li></ul><a id="more"></a><h2 id="传播级别分类"><a href="#传播级别分类" class="headerlink" title="传播级别分类"></a>传播级别分类</h2><ul><li>具体分类如下：   </li></ul><table><thead><tr><th style="text-align:left">传播行为</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>PROPAGATION_REQUIRED</strong></td><td style="text-align:left">如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。（Spring默认行为）</td></tr><tr><td style="text-align:left">PROPAGATION_SUPPORTS</td><td style="text-align:left">支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td style="text-align:left">PROPAGATION_MANDATORY</td><td style="text-align:left">使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td style="text-align:left">PROPAGATION_REQUIRES_NEW</td><td style="text-align:left">新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td style="text-align:left">PROPAGATION_NOT_SUPPORTED</td><td style="text-align:left">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td style="text-align:left">PROPAGATION_NEVER</td><td style="text-align:left">以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td style="text-align:left">PROPAGATION_NESTED</td><td style="text-align:left">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><blockquote><p>NOTE：PROPAGATION_NESTED<strong>嵌套事务</strong>：<br>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫<code>save point</code>，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个<code>save point</code>。</p></blockquote><h2 id="隔离级别分类"><a href="#隔离级别分类" class="headerlink" title="隔离级别分类"></a>隔离级别分类</h2><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>ISOLATION_DEFAULT</strong></td><td style="text-align:left">这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是ISOLATION_READ_COMMITTED。</td></tr><tr><td style="text-align:left">ISOLATION_READ_UNCOMMITTED</td><td style="text-align:left">允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。</td></tr><tr><td style="text-align:left">ISOLATION_READ_COMMITTED</td><td style="text-align:left">允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。（Oracle默认级别）</td></tr><tr><td style="text-align:left">ISOLATION_REPEATABLE_READ</td><td style="text-align:left">对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。（MySQL默认级别）</td></tr><tr><td style="text-align:left">ISOLATION_SERIALIZABLE</td><td style="text-align:left">完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td></tr></tbody></table><ul><li><p><strong>脏读</strong><br>在A事务范围内读取B事务已修改尚未提交的值，会造成脏读。（因为B事务可能会回滚）</p></li><li><p><strong>不可重复读</strong><br>在A事务范围内多次读取某个值，结果会不一样，因为在这期间B事务修改了这个值并提交了事务。</p></li><li><p><strong>幻影读</strong><br>在A事务范围内B事务新增或删除某些值，造成条数不一致。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事务最重要的两个特性，是事务的&lt;strong&gt;传播级别&lt;/strong&gt;和数据&lt;strong&gt;隔离级别&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;传播级别&lt;/strong&gt;定义的是事务的控制范围。&lt;br&gt;&lt;strong&gt;隔离级别&lt;/strong&gt;定义的是事务在数据库读写方面的控制范围。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;都定义在Spring的&lt;code&gt;TransactionDefinition&lt;/code&gt;接口中，传播性有&lt;strong&gt;七种&lt;/strong&gt;，隔离级别有&lt;strong&gt;五种&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（Spring3、Spring4数量都是如此）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://nullhint.org/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub+Coding搭建博客</title>
    <link href="http://nullhint.org/2018/08/31/SetupBlog/"/>
    <id>http://nullhint.org/2018/08/31/SetupBlog/</id>
    <published>2018-08-31T15:30:00.000Z</published>
    <updated>2018-11-03T11:19:32.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过使用<code>Hexo</code>生成静态博客页面，同时发布到<code>Github Page</code>和<code>Coding Page</code>上（为了同时支持谷歌和百度爬虫检索），这样就可以展示个人博客了。</p><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><ul><li><strong><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a></strong>：一款生成静态博客的框架，支持Markdown，自定义渲染静态页面。</li><li><strong><a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a></strong>：用来展示个人Github项目的页面，可以用来部署个人博客。</li><li><strong><a href="https://coding.net/help/doc/pages" target="_blank" rel="external">Coding Pages</a></strong>：类似<code>Github Pages</code>，只是<code>Coding Pages</code>支持百度爬虫检索，而<code>Github Pages</code>无法被百度爬虫检索。</li><li><strong><a href="https://www.godaddy.com" target="_blank" rel="external">GoDaddy</a></strong>：申请个人域名的网站。</li><li><strong><a href="www.dnspod.cn">DNSPod</a></strong>：解析域名的网站，更快更稳定。</li></ul><a id="more"></a><h2 id="Hexo安装使用和主题优化"><a href="#Hexo安装使用和主题优化" class="headerlink" title="Hexo安装使用和主题优化"></a>Hexo安装使用和主题优化</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装前置条件"><a href="#安装前置条件" class="headerlink" title="安装前置条件"></a>安装前置条件</h4><p>安装Hexo前需要先安装以下软件：</p><ul><li><strong><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></strong>：Hexo运行环境。</li><li><strong><a href="https://git-scm.com/" target="_blank" rel="external">Git</a></strong>：Hexo初始化时需要使用Git克隆项目。</li></ul><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>Windows安装Git后，随便找个文件夹，按下鼠标右键，点击<code>Git Bash Here</code>，在以上命令行界面运行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div></pre></td></tr></table></figure></p><blockquote><p>可通过<code>hexo -v</code>查看是否安装成功。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h4><p>通过<code>Git Bash Here</code>命令行界面，输入以下命令，就可以新增一个名为<code>blog</code>的文件夹，里面存放Hexo所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init blog</div></pre></td></tr></table></figure><p><code>blog</code>文件夹目录结构如下：</p><blockquote><p><strong>node_modules</strong><br><strong>scaffolds</strong><br><strong>source</strong>：所有博客文章都放在<code>source/_posts</code>目录下。<br><strong>themes</strong>：存放主题文件。<br><strong>.gitignore</strong><br><strong>_config.yml</strong>：配置文件。<br><strong>package.json</strong></p></blockquote><h4 id="新增文件"><a href="#新增文件" class="headerlink" title="新增文件"></a>新增文件</h4><p>进入<code>blog</code>文件夹，在<code>source/_posts</code>目录下新增<code>MyPostName.md</code>或运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"MyPostName"</span></div></pre></td></tr></table></figure><h4 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h4><p>进入<code>blog</code>文件夹，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g 或 </div><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>运行完成后，会生成<code>public</code>文件夹来存放静态文件。</p><blockquote><p>注意：调用<code>hexo g</code>前要先使用命令<code>hexo clean</code>清理<code>public</code>目录。</p></blockquote><h4 id="部署本地Server"><a href="#部署本地Server" class="headerlink" title="部署本地Server"></a>部署本地Server</h4><p>进入<code>blog</code>文件夹，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>运行完成后，可以通过<strong><a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></strong>访问本地博客。</p><h3 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h3><p>所有主题都放在<code>blog/themes</code>文件夹下，默认的主题是<code>landscape</code>。<br>可以在<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">这里</a>下载主题，保存在<code>themes</code>目录下，然后修改<code>_config.yml</code>文件的以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Extensions</span></div><div class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></div><div class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></div><div class="line"><span class="attr">theme:</span> <span class="string">landscape</span></div></pre></td></tr></table></figure><h2 id="配置并发布到GitHub-Pages"><a href="#配置并发布到GitHub-Pages" class="headerlink" title="配置并发布到GitHub Pages"></a>配置并发布到GitHub Pages</h2><h3 id="配置GitHub-Pages"><a href="#配置GitHub-Pages" class="headerlink" title="配置GitHub Pages"></a>配置GitHub Pages</h3><p><code>GitHub Pages</code>配置参照<a href="https://pages.github.com/" target="_blank" rel="external">官方教程</a>。<br>配置好之后就可以通过<a href="http://{username}.github.io" target="_blank" rel="external">http://{username}.github.io</a>访问<code>GitHub Pages</code>页面。</p><h3 id="发布Hexo生成好的静态页面到GitHub-Pages"><a href="#发布Hexo生成好的静态页面到GitHub-Pages" class="headerlink" title="发布Hexo生成好的静态页面到GitHub Pages"></a>发布Hexo生成好的静态页面到GitHub Pages</h3><p>前面步骤中运行<code>Hexo g</code>命令会在<code>public</code>文件夹中生成所有静态页面，把该文件夹里面的所有内容发布到<code>GitHub Pages</code>项目即可。</p><h2 id="配置并发布到Coding-Pages"><a href="#配置并发布到Coding-Pages" class="headerlink" title="配置并发布到Coding Pages"></a>配置并发布到Coding Pages</h2><h3 id="配置Coding-Pages"><a href="#配置Coding-Pages" class="headerlink" title="配置Coding Pages"></a>配置Coding Pages</h3><p><code>Coding Pages</code>配置参照<a href="https://coding.net/v2/pages/" target="_blank" rel="external">官方教程</a>。<br>配置好后就可以通过<a href="http://{username}.coding.me" target="_blank" rel="external">http://{username}.coding.me</a>访问<code>Coding Pages</code>页面。</p><h3 id="发布Hexo生成好的静态页面到Coding-Pages"><a href="#发布Hexo生成好的静态页面到Coding-Pages" class="headerlink" title="发布Hexo生成好的静态页面到Coding Pages"></a>发布Hexo生成好的静态页面到Coding Pages</h3><p>前面步骤中运行<code>Hexo g</code>命令会在<code>public</code>文件夹中生成所有静态页面，把该文件夹里面的所有内容发布到<code>Coding Pages</code>项目即可。</p><h2 id="为博客自定义域名"><a href="#为博客自定义域名" class="headerlink" title="为博客自定义域名"></a>为博客自定义域名</h2><h3 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h3><p>去<a href="https://sg.godaddy.com/zh/" target="_blank" rel="external">GoDaddy</a>申请域名。</p><h3 id="配置DNS映射到DNSPod"><a href="#配置DNS映射到DNSPod" class="headerlink" title="配置DNS映射到DNSPod"></a>配置DNS映射到DNSPod</h3><p>在GoDaddy管理页面增加以下域名服务器：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f1g1ns1.dnspod.net</div><div class="line">f1g1ns2.dnspod.net</div></pre></td></tr></table></figure><h3 id="在DNSPod页面配置DNS映射到GitHub和Coding地址"><a href="#在DNSPod页面配置DNS映射到GitHub和Coding地址" class="headerlink" title="在DNSPod页面配置DNS映射到GitHub和Coding地址"></a>在DNSPod页面配置DNS映射到GitHub和Coding地址</h3><p>配置内容如下图所示：<br><img src="https://i.loli.net/2018/11/03/5bdd83de55a5e.png" alt="MyDNSPod"></p><ul><li>两个<strong>记录类型</strong>为<code>NS</code>的配置项为上一步映射到DNSPod时自动生成的。</li><li>国内线路默认访问<code>Coding Pages</code>，国外线路则访问<code>GitHub Pages</code>。</li></ul><h3 id="在GitHub-Pages和Coding-Pages项目根目录增加CNAME"><a href="#在GitHub-Pages和Coding-Pages项目根目录增加CNAME" class="headerlink" title="在GitHub Pages和Coding Pages项目根目录增加CNAME"></a>在GitHub Pages和Coding Pages项目根目录增加CNAME</h3><p>在本地Hexo目录的<code>source</code>目录下新建名为<code>CNAME</code>的文件，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myDomin.xxx</div></pre></td></tr></table></figure><p>重新生成静态页面并上传到GitHub，即完成自定义域名映射到GitHub上的博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;通过使用&lt;code&gt;Hexo&lt;/code&gt;生成静态博客页面，同时发布到&lt;code&gt;Github Page&lt;/code&gt;和&lt;code&gt;Coding Page&lt;/code&gt;上（为了同时支持谷歌和百度爬虫检索），这样就可以展示个人博客了。&lt;/p&gt;
&lt;h2 id=&quot;工具介绍&quot;&gt;&lt;a href=&quot;#工具介绍&quot; class=&quot;headerlink&quot; title=&quot;工具介绍&quot;&gt;&lt;/a&gt;工具介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/hexojs/hexo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;&lt;/strong&gt;：一款生成静态博客的框架，支持Markdown，自定义渲染静态页面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub Pages&lt;/a&gt;&lt;/strong&gt;：用来展示个人Github项目的页面，可以用来部署个人博客。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://coding.net/help/doc/pages&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Coding Pages&lt;/a&gt;&lt;/strong&gt;：类似&lt;code&gt;Github Pages&lt;/code&gt;，只是&lt;code&gt;Coding Pages&lt;/code&gt;支持百度爬虫检索，而&lt;code&gt;Github Pages&lt;/code&gt;无法被百度爬虫检索。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.godaddy.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GoDaddy&lt;/a&gt;&lt;/strong&gt;：申请个人域名的网站。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;www.dnspod.cn&quot;&gt;DNSPod&lt;/a&gt;&lt;/strong&gt;：解析域名的网站，更快更稳定。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="http://nullhint.org/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库三大范式</title>
    <link href="http://nullhint.org/2018/08/28/Database_3NF/"/>
    <id>http://nullhint.org/2018/08/28/Database_3NF/</id>
    <published>2018-08-28T05:00:00.000Z</published>
    <updated>2018-08-28T04:40:18.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h2><p>原子性，字段不可再分割。</p><ul><li>第一范式是最基本的范式。如果数据库表中的<strong>所有字段值都是不可分解的原子值</strong>，就说明该数据库表满足了第一范式。</li><li>第一范式的合理遵循需要根据系统的<strong>实际需求</strong>来定。<br>比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式。</li></ul><a id="more"></a><h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h2><p>非主键字段<strong>完全依赖</strong>于主键，没有部分依赖。</p><ul><li>首先要满足第一范式。</li><li>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（<strong>主要针对联合主键而言</strong>）。</li></ul><h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h2><p><strong>非主键字段</strong>不能互相依赖，即没有依赖传递。</p><ul><li>首先要满足第二范式。</li><li>第三范式需要确保数据表中的<strong>每一列数据都和主键直接相关，而不能间接相关</strong>。</li></ul><h2 id="2NF与3NF对比"><a href="#2NF与3NF对比" class="headerlink" title="2NF与3NF对比"></a>2NF与3NF对比</h2><p>第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于：</p><ul><li><strong>2NF</strong>：非主键列是否完全依赖于主键，还是依赖于主键的一部分。</li><li><strong>3NF</strong>：非主键列是直接依赖于主键，还是直接依赖于非主键列。</li></ul><p>粗略地理解：2NF，处理不合理的复合主键，3NF，处理单主键表的非主键列。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一范式-1NF&quot;&gt;&lt;a href=&quot;#第一范式-1NF&quot; class=&quot;headerlink&quot; title=&quot;第一范式(1NF)&quot;&gt;&lt;/a&gt;第一范式(1NF)&lt;/h2&gt;&lt;p&gt;原子性，字段不可再分割。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一范式是最基本的范式。如果数据库表中的&lt;strong&gt;所有字段值都是不可分解的原子值&lt;/strong&gt;，就说明该数据库表满足了第一范式。&lt;/li&gt;
&lt;li&gt;第一范式的合理遵循需要根据系统的&lt;strong&gt;实际需求&lt;/strong&gt;来定。&lt;br&gt;比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="http://nullhint.org/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World程序执行过程</title>
    <link href="http://nullhint.org/2018/02/12/JVM_HelloWorld/"/>
    <id>http://nullhint.org/2018/02/12/JVM_HelloWorld/</id>
    <published>2018-02-12T10:00:00.000Z</published>
    <updated>2018-02-12T09:29:07.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文分析<strong>Windows平台</strong>下，一个简单Hello World程序从编译到运行所经历的大致过程，<code>Test.java</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello world!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol><li>命令行执行<code>javac Test.java</code>，编译成<code>.class</code>文件。</li><li>命令行执行<code>java Test</code>，控制台打印结果<code>Hello World!</code>。</li></ol><h2 id="执行步骤详细分析"><a href="#执行步骤详细分析" class="headerlink" title="执行步骤详细分析"></a>执行步骤详细分析</h2><h3 id="一、把-java文件编译成-class"><a href="#一、把-java文件编译成-class" class="headerlink" title="一、把.java文件编译成.class"></a>一、把.java文件编译成.class</h3><p>执行<code>javac Test.java</code>命令时，javac编译器将按照《Java虚拟机规范》把<code>Test.java</code>源文件编译成平台无关的<code>Test.class</code>文件，该Class文件的结构可以被虚拟机识别。</p><h3 id="二、加载-class文件到JVM"><a href="#二、加载-class文件到JVM" class="headerlink" title="二、加载.class文件到JVM"></a>二、加载.class文件到JVM</h3><p>执行<code>java Test</code>命令时，<code>java.exe</code>会装载<code>jvm.dll</code>这个动态链接库，启动虚拟机进程，把<code>Test.class</code>文件加载到虚拟机内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。具体的<strong>类加载过程</strong>如下：</p><ol><li><strong>加载</strong>：应用程序类加载器（Application ClassLoader）获取<code>Test.class</code>的二进制字节流，将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构，并在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li><li><strong>验证</strong>：虚拟机对该Class文件的字节流进行一系列验证（文件格式验证、元数据验证、字节码验证、符号引用验证），确保符合当前虚拟机的要求，不会危害到虚拟机。</li><li><strong>准备</strong>：为<strong>类变量</strong>（被static修饰的变量）分配内存并设置初始值，这些变量所使用的内存都将在方法区中进行分配。</li><li><strong>解析</strong>：虚拟机常量池内的符号引用替换为直接引用。</li><li><strong>初始化</strong>：根据程序员自定义的内容去初始化类变量和其他资源。</li></ol><h3 id="三、JVM执行字节码"><a href="#三、JVM执行字节码" class="headerlink" title="三、JVM执行字节码"></a>三、JVM执行字节码</h3><p>使用<code>javap -v Test</code>命令，可以看到<code>main()</code>方法字节码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void main(java.lang.String[]);</div><div class="line">  descriptor: ([Ljava/lang/String;)V</div><div class="line">  flags: ACC_PUBLIC, ACC_STATIC</div><div class="line">  Code:</div><div class="line">    stack=2, locals=1, args_size=1</div><div class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">       3: ldc           #3                  // String Hello World!</div><div class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</div><div class="line">       8: return</div><div class="line">    LineNumberTable:</div><div class="line">      line 5: 0</div><div class="line">      line 6: 8</div><div class="line">    LocalVariableTable:</div><div class="line">      Start  Length  Slot  Name   Signature</div><div class="line">          0       9     0  args   [Ljava/lang/String;</div></pre></td></tr></table></figure><p>详细字节码指令执行步骤如下：</p><ol><li>执行<code>getstatic</code>指令，把<code>static</code>修饰的<code>System.out</code>的引用存入当前栈帧的<strong>操作数栈</strong>。</li><li>执行<code>ldc</code>指令，把字符串<code>Hello World!</code>的引用从运行时常量池中存入<strong>操作数栈</strong>。</li><li>执行<code>invokevirtual</code>指令，调用<code>PrintStream.println()</code>方法，该指令会使用前两步操作存入操作数栈的值。</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>《深入理解Java虚拟机》<br>《The Java Virtual Machine Specification》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文分析&lt;strong&gt;Windows平台&lt;/strong&gt;下，一个简单Hello World程序从编译到运行所经历的大致过程，&lt;code&gt;Test.java&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://nullhint.org/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JUC.ConcurrentHashMap实现原理</title>
    <link href="http://nullhint.org/2018/01/11/Java_ConcurrentHashMap/"/>
    <id>http://nullhint.org/2018/01/11/Java_ConcurrentHashMap/</id>
    <published>2018-01-11T12:00:00.000Z</published>
    <updated>2018-11-03T11:22:33.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>ConcurrentHashMap</code>是一个支持并发读写和自定义并发级别的Hash Table。</p><p>主要特性如下：</p><ul><li><code>ConcurrentHashMap</code>是线程安全的。</li><li><code>ConcurrentHashMap</code>使用锁分段技术，在执行写操作时，只锁住部分的Map。</li><li><code>ConcurrentHashMap</code>的key和value不允许为null。</li><li><code>ConcurrentHashMap</code>返回的迭代器是弱一致性、fail-safe的并且不会抛出<code>ConcurrentModificationException</code>异常。</li></ul><a id="more"></a><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</div><div class="line">map.put(<span class="string">"key"</span>, <span class="string">"value"</span>);</div><div class="line">map.get(<span class="string">"key"</span>);</div></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>ConcurrentHashMap</code>内部持有一个<code>Segment&lt;K,V&gt;[]</code>数组，<code>Segment</code>继承自<code>ReentrantLock</code>以方便使用锁。<br><code>Segment</code>内部结构类似于<code>HashMap</code>，使用一个数组链表结构保存键值对。如下图所示：<br><img src="https://i.loli.net/2018/11/03/5bdd8495b5b00.png" alt="ConcurrentHashMap数据结构图"></p><p><img src="https://i.loli.net/2018/11/03/5bdd8495ba9f5.png" alt="ConcurrentHashMap类图"></p><h2 id="JDK1-7源码分析"><a href="#JDK1-7源码分析" class="headerlink" title="JDK1.7源码分析"></a>JDK1.7源码分析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个空的map，构造map中的Segment数组，并初始化第0个Segment。</span></div><div class="line"><span class="comment">// 方法参数如下：</span></div><div class="line"><span class="comment">//     @param initialCapacity: 初始容量。</span></div><div class="line"><span class="comment">//     @param loadFactor: 负载因子。</span></div><div class="line"><span class="comment">//     @param concurrencyLevel: 并发级别。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">        concurrencyLevel = MAX_SEGMENTS;</div><div class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></div><div class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</div><div class="line">        ++sshift;</div><div class="line">        ssize &lt;&lt;= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</div><div class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</div><div class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">        ++c;</div><div class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</div><div class="line">    <span class="keyword">while</span> (cap &lt; c)</div><div class="line">        cap &lt;&lt;= <span class="number">1</span>;</div><div class="line">    <span class="comment">// create segments and segments[0]</span></div><div class="line">    Segment&lt;K,V&gt; s0 =</div><div class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</div><div class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</div><div class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</div><div class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></div><div class="line">    <span class="keyword">this</span>.segments = ss;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该方法主要做以下事情：</span></div><div class="line"><span class="comment">//     1. 调用hash()方法对key进行重新hash。</span></div><div class="line"><span class="comment">//     2. 根据key的hash值，获取该键值对应该存放在Segment数组的哪一项（如果该Segment不存在，则创建它）。</span></div><div class="line"><span class="comment">//     3. 调用Segment的put()方法存储键值对。</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Segment&lt;K,V&gt; s;</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></div><div class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></div><div class="line">        s = ensureSegment(j);</div><div class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Segment的put()方法主要做以下事情：</span></div><div class="line"><span class="comment">//     1. 尝试获取锁，如果锁被占用，调用scanAndLockForPut()方法确保进入该方法时持有锁。</span></div><div class="line"><span class="comment">//     2. 根据key的hash值获取该键值对在HashEntry数组中的索引index。</span></div><div class="line"><span class="comment">//     3. 根据index获取HashEntry数组中的首个HashEntry。</span></div><div class="line"><span class="comment">//     4. 遍历HashEntry链表，如果key匹配，则替换为新值，如果不存在跟key匹配的HashEntry或HashEntry为空，则创建HashEntry。</span></div><div class="line"><span class="comment">//     5. 如果该Segment中的HashEntry数量超过一定阈值，则调用rehash()进行扩容。</span></div><div class="line"><span class="comment">//     6. 在finally中释放锁。</span></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</div><div class="line">        scanAndLockForPut(key, hash, value);</div><div class="line">    V oldValue;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</div><div class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">                K k;</div><div class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</div><div class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                    oldValue = e.value;</div><div class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</div><div class="line">                        e.value = value;</div><div class="line">                        ++modCount;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                e = e.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</div><div class="line">                    node.setNext(first);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                    rehash(node);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    setEntryAt(tab, index, node);</div><div class="line">                ++modCount;</div><div class="line">                count = c;</div><div class="line">                oldValue = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该方法主要做以下事情：</span></div><div class="line"><span class="comment">//     1. 调用hash()对key进行重新hash。</span></div><div class="line"><span class="comment">//     2. 根据key的hash值获取Segment数组的Segment。</span></div><div class="line"><span class="comment">//     3. 根据key的hash值，获取Segment中HashEntry数组中的HashEntry。</span></div><div class="line"><span class="comment">//     4. 遍历HashEntry链表，返回匹配key的value。</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></div><div class="line">    HashEntry&lt;K,V&gt;[] tab;</div><div class="line">    <span class="keyword">int</span> h = hash(key);</div><div class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            K k;</div><div class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="rehash过程"><a href="#rehash过程" class="headerlink" title="rehash过程"></a>rehash过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当Segment中HashEntry的数量超过一定阈值之后，会调用该方法进行重新hash，实现步骤如下：</span></div><div class="line"><span class="comment">//     1. 扩充容量为原来的2倍。</span></div><div class="line"><span class="comment">//     2. 遍历原数组链表，根据每个键值对的hash值重新计算新数组索引。（程序会重用部分HashEntry以节约资源）</span></div><div class="line"><span class="comment">//     3. 因为rehash()是在put()方法里被调用的，所以把要新增的节点也放到数组链表结构中。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</div><div class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</div><div class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">    HashEntry&lt;K,V&gt;[] newTable =</div><div class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</div><div class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</div><div class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            HashEntry&lt;K,V&gt; next = e.next;</div><div class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</div><div class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></div><div class="line">                newTable[idx] = e;</div><div class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></div><div class="line">                HashEntry&lt;K,V&gt; lastRun = e;</div><div class="line">                <span class="keyword">int</span> lastIdx = idx;</div><div class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</div><div class="line">                     last != <span class="keyword">null</span>;</div><div class="line">                     last = last.next) &#123;</div><div class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</div><div class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</div><div class="line">                        lastIdx = k;</div><div class="line">                        lastRun = last;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                newTable[lastIdx] = lastRun;</div><div class="line">                <span class="comment">// Clone remaining nodes</span></div><div class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</div><div class="line">                    V v = p.value;</div><div class="line">                    <span class="keyword">int</span> h = p.hash;</div><div class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</div><div class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</div><div class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></div><div class="line">    node.setNext(newTable[nodeIndex]);</div><div class="line">    newTable[nodeIndex] = node;</div><div class="line">    table = newTable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;是一个支持并发读写和自定义并发级别的Hash Table。&lt;/p&gt;
&lt;p&gt;主要特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;是线程安全的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;使用锁分段技术，在执行写操作时，只锁住部分的Map。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;的key和value不允许为null。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;返回的迭代器是弱一致性、fail-safe的并且不会抛出&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JDK源码" scheme="http://nullhint.org/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Java线程池实现原理</title>
    <link href="http://nullhint.org/2017/12/29/Java_ThreadPool/"/>
    <id>http://nullhint.org/2017/12/29/Java_ThreadPool/</id>
    <published>2017-12-29T13:00:00.000Z</published>
    <updated>2017-12-29T12:40:56.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java线程池的实现类为：<code>ThreadPoolExecutor</code>，线程池主要用于以下两种情况：</p><ol><li>用于改善性能。当执行大量异步任务时，减少每个任务调用的开销。</li><li>用于管理资源。</li></ol><a id="more"></a><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>,</div><div class="line">                TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</div><div class="line">            MyTask myTask = <span class="keyword">new</span> MyTask(i);</div><div class="line">            executor.execute(myTask);</div><div class="line">            System.out.println(<span class="string">"Pool sizes is "</span> + executor.getPoolSize() + <span class="string">", Queue size is "</span> + executor.getQueue().size()</div><div class="line">                    + <span class="string">", Completed task count is "</span> + executor.getCompletedTaskCount());</div><div class="line">        &#125;</div><div class="line">        executor.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</div><div class="line"></div><div class="line">    MyTask(<span class="keyword">int</span> taskNum) &#123;</div><div class="line">        <span class="keyword">this</span>.taskNum = taskNum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Running task-"</span> + taskNum + <span class="string">"."</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">4000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"Task-"</span> + taskNum + <span class="string">" finished."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>运行结果如下：<blockquote><p>Running task-1.<br>Pool sizes is 1, Queue size is 0, Completed task count is 0<br>Pool sizes is 2, Queue size is 0, Completed task count is 0<br>Running task-2.<br>Pool sizes is 3, Queue size is 0, Completed task count is 0<br>Running task-3.<br>Pool sizes is 4, Queue size is 0, Completed task count is 0<br>Running task-4.<br>Pool sizes is 5, Queue size is 0, Completed task count is 0<br>Running task-5.<br>Pool sizes is 5, Queue size is 1, Completed task count is 0<br>Pool sizes is 5, Queue size is 2, Completed task count is 0<br>Pool sizes is 5, Queue size is 3, Completed task count is 0<br>Pool sizes is 5, Queue size is 4, Completed task count is 0<br>Pool sizes is 5, Queue size is 5, Completed task count is 0<br>Pool sizes is 6, Queue size is 5, Completed task count is 0<br>Running task-11.<br>Pool sizes is 7, Queue size is 5, Completed task count is 0<br>Running task-12.<br>Pool sizes is 8, Queue size is 5, Completed task count is 0<br>Running task-13.<br>Pool sizes is 9, Queue size is 5, Completed task count is 0<br>Running task-14.<br>Pool sizes is 10, Queue size is 5, Completed task count is 0<br>Running task-15.<br>Task-4 finished.<br>Task-12 finished.<br>Task-13 finished.<br>Task-14 finished.<br>Running task-7.<br>Task-5 finished.<br>Task-2 finished.<br>Task-3 finished.<br>Task-15 finished.<br>Task-1 finished.<br>Running task-9.<br>Running task-8.<br>Task-11 finished.<br>Running task-6.<br>Running task-10.<br>Task-10 finished.<br>Task-7 finished.<br>Task-6 finished.<br>Task-8 finished.<br>Task-9 finished.</p></blockquote></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="线程池的创建（构造函数）"><a href="#线程池的创建（构造函数）" class="headerlink" title="线程池的创建（构造函数）"></a>线程池的创建（构造函数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 存在多个重载版本的构造函数，此为参数最完整的一个。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize: 基本的线程池大小。</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize: 最大允许创建的线程数。</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime: 保持线程活动的时间。</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> unit: 保持线程活动时间的单位。</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue: 用于保存等待执行的任务的阻塞队列。</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory: 创建线程的工厂。</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> handler: 当队列和线程池都满了，采用的处理提交的新任务的策略。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></div><div class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></div><div class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></div><div class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></div><div class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// ......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="部分参数解析"><a href="#部分参数解析" class="headerlink" title="部分参数解析"></a>部分参数解析</h4><h5 id="任务队列（BlockingQueue）"><a href="#任务队列（BlockingQueue）" class="headerlink" title="任务队列（BlockingQueue）"></a>任务队列（BlockingQueue）</h5><p><strong>任务队列的使用与线程池大写有关：</strong></p><ol><li>如果<code>当前运行的线程数 &lt; corePoolSize</code>，那么执行器会创建新线程来处理新的任务。</li><li>如果<code>当前运行的线程数 &gt;= corePoolSize</code>，那么执行器会把新任务存入队列。</li><li>如果新任务不能存入队列，那么创建新线程来处理它。</li></ol><p><strong>有以下三种常用的队列策略：</strong></p><ol><li>直接传递（Direct handoffs），例如使用<code>SynchronousQueue</code>。</li><li>无界队列（Unbounded queues），例如使用<code>LinkedBlockingQueue</code>。</li><li>有界队列（Bounded queues），例如使用<code>ArrayBlockingQueue</code>。</li></ol><h5 id="饱和策略（RejectedExecutionHandler）"><a href="#饱和策略（RejectedExecutionHandler）" class="headerlink" title="饱和策略（RejectedExecutionHandler）"></a>饱和策略（RejectedExecutionHandler）</h5><ol><li><code>ThreadPoolExecutor.AbortPolicy</code>（默认策略）：抛出运行时异常。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：只用调用者所在线程来运行任务。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：丢弃该任务。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列头对应的任务，然后重新执行当前任务。</li></ol><h3 id="向线程池提交任务（execute-或submit-方法）"><a href="#向线程池提交任务（execute-或submit-方法）" class="headerlink" title="向线程池提交任务（execute()或submit()方法）"></a>向线程池提交任务（execute()或submit()方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 当前正在运行的线程小于corePoolSize时，调用addWorker()尝试增加新的线程来处理该任务，并结束本方法。</span></div><div class="line"><span class="comment">// 2. 否则，把任务加入任务队列，新建线程处理任务队列中的任务。如果任务被拒绝，调用reject()方法执行饱和策略。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="线程池的关闭（shutdown-或shutdownNow-方法）"><a href="#线程池的关闭（shutdown-或shutdownNow-方法）" class="headerlink" title="线程池的关闭（shutdown()或shutdownNow()方法）"></a>线程池的关闭（shutdown()或shutdownNow()方法）</h3><ul><li><code>shutdown()</code>或<code>shutdownNow()</code>方法可以关闭线程池，通过逐个调用<code>interrupt()</code>来中断线程池中的工作线程。</li><li><code>shutdown()</code>与<code>shutdownNow()</code>的区别在于：<code>shutdown()</code>不中断正在执行的任务，而<code>shutdownNow()</code>会尝试中断正在执行的任务，并返回等待执行的任务列表。</li></ul><h2 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h2><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><ul><li>如果当前线程池有可用线程，则重用该线程处理任务，否则，直接创建新线程处理任务。</li><li>当线程闲置超过1分钟，则被回收。</li><li>当执行多个短周期的异步任务时，该类线程池可以提高性能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用ThreadPoolExecutor()参数如下：</span></div><div class="line">    <span class="comment">// corePoolSize ==&gt; 0</span></div><div class="line">    <span class="comment">// maximumPoolSize ==&gt; Integer.MAX_VALUE</span></div><div class="line">    <span class="comment">// keepAliveTime ==&gt; 60L</span></div><div class="line">    <span class="comment">// timeUnit ==&gt; TimeUnit.SECONDS</span></div><div class="line">    <span class="comment">// BlockingQueue ==&gt; new SynchronousQueue&lt;Runnable&gt;()</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>该线程池会重用固定数目的线程，并使用无界队列暂存待处理的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用ThreadPoolExecutor()参数如下：</span></div><div class="line">    <span class="comment">// corePoolSize ==&gt; nThreads</span></div><div class="line">    <span class="comment">// maximumPoolSize ==&gt; nThreads</span></div><div class="line">    <span class="comment">// keepAliveTime ==&gt; 0L</span></div><div class="line">    <span class="comment">// timeUnit ==&gt; TimeUnit.MILLISECONDS</span></div><div class="line">    <span class="comment">// BlockingQueue ==&gt; new LinkedBlockingQueue&lt;Runnable&gt;()</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>该线程池可以设置延迟执行或定时执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="comment">// super为ThreadPoolExecutor类，参数如下：</span></div><div class="line">    <span class="comment">// corePoolSize ==&gt; corePoolSize</span></div><div class="line">    <span class="comment">// maximumPoolSize ==&gt; Integer.MAX_VALUE</span></div><div class="line">    <span class="comment">// keepAliveTime ==&gt; 0</span></div><div class="line">    <span class="comment">// timeUnit ==&gt; TimeUnit.NANOSECONDS</span></div><div class="line">    <span class="comment">// BlockingQueue ==&gt; new DelayedWorkQueue()</span></div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>该线程池仅使用单个线程来处理任务，同时使用无界队列存储待处理的任务，可以保证执行任务的顺序性，同一时刻不存在多个任务同时被处理。<br>与<code>newFixedThreadPool(1)</code>的区别是该线程池确保无法通过重新配置来增加线程数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">        <span class="comment">// 参数如下：</span></div><div class="line">        <span class="comment">// corePoolSize ==&gt; 1</span></div><div class="line">        <span class="comment">// maximumPoolSize ==&gt; 1</span></div><div class="line">        <span class="comment">// keepAliveTime ==&gt; 0L</span></div><div class="line">        <span class="comment">// timeUnit ==&gt; TimeUnit.MILLISECONDS</span></div><div class="line">        <span class="comment">// BlockingQueue ==&gt; new LinkedBlockingQueue&lt;Runnable&gt;()</span></div><div class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SingleThreadScheduledExecutor"><a href="#SingleThreadScheduledExecutor" class="headerlink" title="SingleThreadScheduledExecutor"></a>SingleThreadScheduledExecutor</h3><p>该线程池可以设置延迟执行或定时执行任务，且确保仅使用单个线程处理任务。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-threadPool</a><br><a href="http://cuisuqiang.iteye.com/blog/2019372" target="_blank" rel="external">http://cuisuqiang.iteye.com/blog/2019372</a><br><a href="http://singleant.iteye.com/blog/1423931" target="_blank" rel="external">http://singleant.iteye.com/blog/1423931</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java线程池的实现类为：&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;，线程池主要用于以下两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用于改善性能。当执行大量异步任务时，减少每个任务调用的开销。&lt;/li&gt;
&lt;li&gt;用于管理资源。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JDK源码" scheme="http://nullhint.org/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>JUC.CyclicBarrier实现原理</title>
    <link href="http://nullhint.org/2017/12/20/JUC_CyclicBarrier/"/>
    <id>http://nullhint.org/2017/12/20/JUC_CyclicBarrier/</id>
    <published>2017-12-20T02:00:00.000Z</published>
    <updated>2017-12-20T13:50:49.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>CyclicBarrier</code>是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点。因为该barrier在释放等待线程后可以重用，所以称它为循环的barrier。<br>（A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.  CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other.）</p><h2 id="CountDownLatch-vs-CyclicBarrier"><a href="#CountDownLatch-vs-CyclicBarrier" class="headerlink" title="CountDownLatch vs CyclicBarrier"></a>CountDownLatch vs CyclicBarrier</h2><ul><li>一旦满足barrier条件后，<code>CyclicBarrier</code>可以执行一个（可选的）<code>Runnable</code>任务。</li><li>所有等待线程被释放后，<code>CyclicBarrier</code>是可以重用的。</li><li><code>CyclicBarrier</code>常用于复杂的并行计算。</li></ul><a id="more"></a><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>以下是使用<code>barrier</code>进行并行分解设计的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> <span class="keyword">int</span> N;</div><div class="line">  <span class="keyword">final</span> <span class="keyword">float</span>[][] data;</div><div class="line">  <span class="keyword">final</span> CyclicBarrier barrier;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> myRow;</div><div class="line">    Worker(<span class="keyword">int</span> row) &#123; myRow = row; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">while</span> (!done()) &#123;</div><div class="line">        processRow(myRow);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          barrier.await();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Solver</span><span class="params">(<span class="keyword">float</span>[][] matrix)</span> </span>&#123;</div><div class="line">    data = matrix;</div><div class="line">    N = matrix.length;</div><div class="line">    barrier = <span class="keyword">new</span> CyclicBarrier(N,</div><div class="line">                                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                    mergeRows(...);</div><div class="line">                                  &#125;</div><div class="line">                                &#125;);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</div><div class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(i)).start();</div><div class="line"></div><div class="line">    waitUntilDone();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>CyclicBarrier</code>是通过<code>ReentrantLock</code>（独占锁）和<code>Condition</code>来实现的。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// parties：指定需要调用await()方法的线程数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// parties：指定需要调用await()方法的线程数</span></div><div class="line"><span class="comment">// barrierAction：指定当barrier完成等待后执行的命令</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">this</span>.parties = parties;</div><div class="line">    <span class="keyword">this</span>.count = parties;</div><div class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="await-方法"><a href="#await-方法" class="headerlink" title="await()方法"></a>await()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一直等待，直到这个barrier的所有部分都调用了await()方法。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// timeout：等待barrier的时间</span></div><div class="line"><span class="comment">// unit：等待时间的单位</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></div><div class="line"><span class="function">           BrokenBarrierException,</span></div><div class="line"><span class="function">           TimeoutException </span>&#123;</div><div class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注：使用内部类Generation表示barrier，每完成一整个循环就重新生成一个Generation。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></div><div class="line"><span class="function">           TimeoutException </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> Generation g = generation;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (g.broken)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">            breakBarrier();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> index = --count;</div><div class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">           <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">               <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">                   command.run();</div><div class="line">               ranAction = <span class="keyword">true</span>;</div><div class="line">               nextGeneration();</div><div class="line">               <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">           &#125; <span class="keyword">finally</span> &#123;</div><div class="line">               <span class="keyword">if</span> (!ranAction)</div><div class="line">                   breakBarrier();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!timed)</div><div class="line">                    trip.await();</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</div><div class="line">                    nanos = trip.awaitNanos(nanos);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> ie;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></div><div class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></div><div class="line">                    <span class="comment">// "belong" to subsequent execution.</span></div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (g.broken)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (g != generation)</div><div class="line">                <span class="keyword">return</span> index;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CyclicBarrier&lt;/code&gt;是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点。因为该barrier在释放等待线程后可以重用，所以称它为循环的barrier。&lt;br&gt;（A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.  CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other.）&lt;/p&gt;
&lt;h2 id=&quot;CountDownLatch-vs-CyclicBarrier&quot;&gt;&lt;a href=&quot;#CountDownLatch-vs-CyclicBarrier&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch vs CyclicBarrier&quot;&gt;&lt;/a&gt;CountDownLatch vs CyclicBarrier&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一旦满足barrier条件后，&lt;code&gt;CyclicBarrier&lt;/code&gt;可以执行一个（可选的）&lt;code&gt;Runnable&lt;/code&gt;任务。&lt;/li&gt;
&lt;li&gt;所有等待线程被释放后，&lt;code&gt;CyclicBarrier&lt;/code&gt;是可以重用的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CyclicBarrier&lt;/code&gt;常用于复杂的并行计算。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JDK源码" scheme="http://nullhint.org/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://nullhint.org/2017/12/10/Java_CommandPattern/"/>
    <id>http://nullhint.org/2017/12/10/Java_CommandPattern/</id>
    <published>2017-12-10T15:00:00.000Z</published>
    <updated>2018-11-03T11:24:30.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。<br>Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>命令模式将发出请求的对象和执行请求的对象解耦。</li><li>在被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接收者和一个或一组动作。</li></ul><a id="more"></a><h2 id="通用类图"><a href="#通用类图" class="headerlink" title="通用类图"></a>通用类图</h2><p><img src="https://i.loli.net/2018/11/03/5bdd8547d78c4.jpg" alt="命令模式通用类图"></p><p>在该类图中，有三个角色：</p><ul><li><p>Recieve接收者角色<br>该角色就是干活的角色，命令传递到这里是应该被执行的。</p></li><li><p>Command命令角色<br>需要执行的所有命令都在这里声明。</p></li><li><p>Invoker调用者角色<br>接收到命令，并执行命令。</p></li></ul><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><h3 id="通用Receiver类"><a href="#通用Receiver类" class="headerlink" title="通用Receiver类"></a>通用Receiver类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</div><div class="line">    <span class="comment">// 抽象接收者，定义每个接收者都必须完成的业务</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="具体Receiver类"><a href="#具体Receiver类" class="headerlink" title="具体Receiver类"></a>具体Receiver类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteReceiver1</span> <span class="keyword">extends</span> <span class="title">Receiver</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个接收者都必须处理一定的业务逻辑</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteReceiver2</span> <span class="keyword">extends</span> <span class="title">Receiver</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个接收者都必须处理一定的业务逻辑</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="抽象的Command类"><a href="#抽象的Command类" class="headerlink" title="抽象的Command类"></a>抽象的Command类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个命令类都必须有一个执行命令的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="具体的Command类"><a href="#具体的Command类" class="headerlink" title="具体的Command类"></a>具体的Command类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Receiver receiver;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand1</span><span class="params">(Receiver _receiver)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.receiver = _receiver;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        receiver.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Receiver receiver;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand2</span><span class="params">(Receiver _receiver)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.receiver = _receiver;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        receiver.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="调用者Invoker类"><a href="#调用者Invoker类" class="headerlink" title="调用者Invoker类"></a>调用者Invoker类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Command command;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.command = command;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</div><div class="line">        command.execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="场景类"><a href="#场景类" class="headerlink" title="场景类"></a>场景类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Invoker invoker = <span class="keyword">new</span> Invoker();</div><div class="line"></div><div class="line">        Receiver receiver = <span class="keyword">new</span> ConcreteReceiver1();</div><div class="line">        Command command = <span class="keyword">new</span> ConcreteCommand1(receiver);</div><div class="line">        invoker.setCommand(command);</div><div class="line">        invoker.action();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>《Head First设计模式》<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。&lt;br&gt;Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.&lt;/p&gt;
&lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;命令模式将发出请求的对象和执行请求的对象解耦。&lt;/li&gt;
&lt;li&gt;在被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接收者和一个或一组动作。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://nullhint.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JUC.Semaphore实现原理</title>
    <link href="http://nullhint.org/2017/11/17/JUC_Semaphore/"/>
    <id>http://nullhint.org/2017/11/17/JUC_Semaphore/</id>
    <published>2017-11-17T13:40:00.000Z</published>
    <updated>2017-11-17T13:33:36.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><code>Semaphore</code>（信号量）通过构造函数设定一定数目的许可，通过<code>acquire()</code>方法获得许可，<code>release()</code>释放许可。</li><li><code>Semaphore</code>常用来限制访问某些特定资源的线程数。</li><li><code>Semaphore</code>初始化为只有一个许可时，称为<em>binary semaphore</em>，变成了一种互斥锁。</li><li><code>Semaphore</code>可以通过构造器参数设置成公平和非公平模式。</li></ul><a id="more"></a><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>以下示例使用一个<code>Semaphore</code>去控制数据池的访问数量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    available.acquire();</div><div class="line">    <span class="keyword">return</span> getNextAvailableItem();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (markAsUnused(x))</div><div class="line">      available.release();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Not a particularly efficient data structure; just for demo</span></div><div class="line"></div><div class="line">  <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</div><div class="line">      <span class="keyword">if</span> (!used[i]) &#123;</div><div class="line">         used[i] = <span class="keyword">true</span>;</div><div class="line">         <span class="keyword">return</span> items[i];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</div><div class="line">      <span class="keyword">if</span> (item == items[i]) &#123;</div><div class="line">         <span class="keyword">if</span> (used[i]) &#123;</div><div class="line">           used[i] = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">         &#125; <span class="keyword">else</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>Semaphore</code>使用内部类<code>Sync</code>做一系列的锁控制，该类继承自<code>AQS(AbstractQueuedSynchronizer，队列同步器)</code>，提供公平和非公平两种模式，默认是非公平模式。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// permits指定最大允许许可数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// permits指定最大允许许可数，</span></div><div class="line"><span class="comment">// fair指定是否实现公平模式。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="acquire-方法"><a href="#acquire-方法" class="headerlink" title="acquire()方法"></a>acquire()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用继承自AQS的内部类Sync实现该方法，</span></div><div class="line"><span class="comment">// 默认获取1个许可。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用继承自AQS的内部类Sync实现该方法，</span></div><div class="line"><span class="comment">// permits参数指定一次性获取的许可数。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    sync.acquireSharedInterruptibly(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 如果发生中断，则抛出异常。</span></div><div class="line"><span class="comment">// 2. 调用tryAcquireShared()尝试获取许可。</span></div><div class="line"><span class="comment">// 3. 如果上一步尝试获取许可失败，调用doAcquireSharedInterruptibly()把当前线程构造成节点，并加入等待队列。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 非公平模式尝试获取许可。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 减去特定数目的许可数。</span></div><div class="line"><span class="comment">// 如果结果不小于0，表示获取许可成功；如果结果小于0，标识获取许可失败。</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> available = getState();</div><div class="line">        <span class="keyword">int</span> remaining = available - acquires;</div><div class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">            compareAndSetState(available, remaining))</div><div class="line">            <span class="keyword">return</span> remaining;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 公平模式下尝试获取许可。</span></div><div class="line"><span class="comment">// 比非公平模式多了hasQueuedPredecessors()，该方法判断等待队列中最长等待时间的节点持有的是否为当前线程。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> available = getState();</div><div class="line">        <span class="keyword">int</span> remaining = available - acquires;</div><div class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">            compareAndSetState(available, remaining))</div><div class="line">            <span class="keyword">return</span> remaining;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该方法主要做以下事情：</span></div><div class="line"><span class="comment">// 1. 调用addWaiter()方法，增加新节点到队列末端（该队列用双向链表实现），该节点持有当前线程的引用。</span></div><div class="line"><span class="comment">// 2. 让线程在for循环里自旋，如果节点的前继节点是head节点，尝试获取共享锁。</span></div><div class="line"><span class="comment">// 如果获取成功，调用tryAcquireShared()方法，把当前节点设置成head节点，并唤醒等待队列的后继节点，跳出循环，结束该方法。</span></div><div class="line"><span class="comment">// 3. 调用shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()方法让等待节点阻塞等待。</span></div><div class="line"><span class="comment">// 4. 跳出for循环后，如果获取许可失败，则调用cancelAcquire()方法把当前节点从等待队列中移除。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    setHeadAndPropagate(node, r);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="release-方法"><a href="#release-方法" class="headerlink" title="release()方法"></a>release()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认释放一个许可。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// permits参数可以指定释放的许可数目。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    sync.releaseShared(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用tryReleaseShared()尝试释放许可。</span></div><div class="line"><span class="comment">// 如果上一步尝试释放成功，调用doReleaseShared()XXXXX。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">        doReleaseShared();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 尝试释放许可，增加releases个许可数目。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> current = getState();</div><div class="line">        <span class="keyword">int</span> next = current + releases;</div><div class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用unparkSuccessor()唤醒head的后继节点。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                unparkSuccessor(h);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;（信号量）通过构造函数设定一定数目的许可，通过&lt;code&gt;acquire()&lt;/code&gt;方法获得许可，&lt;code&gt;release()&lt;/code&gt;释放许可。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;常用来限制访问某些特定资源的线程数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;初始化为只有一个许可时，称为&lt;em&gt;binary semaphore&lt;/em&gt;，变成了一种互斥锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;可以通过构造器参数设置成公平和非公平模式。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JDK源码" scheme="http://nullhint.org/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock实现原理</title>
    <link href="http://nullhint.org/2017/11/15/ReentrantLock/"/>
    <id>http://nullhint.org/2017/11/15/ReentrantLock/</id>
    <published>2017-11-15T12:30:00.000Z</published>
    <updated>2017-11-15T12:30:21.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>ReentrantLock</code>从API层面实现互斥锁，而<code>synchronized</code>关键字则从JVM层面来实现互斥锁。<br><code>ReentrantLock</code>可以实现公平锁和非公平锁，而<code>synchronized</code>只能是非公平锁。<br><code>ReentrantLock</code>可以绑定多个Conditon。</p><a id="more"></a><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</div><div class="line">    lock.lock();  <span class="comment">// block until condition holds</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// ... method body</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      lock.unlock()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>ReentrantLock</code>继承自<code>Lock</code>接口，使用内部类<code>Sync</code>做一系列的锁控制，该类基于<code>AQS(AbstractQueuedSynchronizer，队列同步器)</code>的“互斥模式”，并且，通过继承自<code>Sync</code>的两个静态内部类<code>FairSync</code>和<code>NonfairSync</code>实现公平锁和非公平锁。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造器参数可以指定实现公平锁还是非公平锁，默认是实现非公平锁。公平锁倾向于等待时间最长的线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="lock-方法"><a href="#lock-方法" class="headerlink" title="lock()方法"></a>lock()方法</h3><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 如果state属性为0，表示未加锁，则通过CAS让state增1，并记录当前线程持有锁。</span></div><div class="line"><span class="comment">// 2. 如果state属性不为0，表示已经加锁，则调用acquire()尝试获取锁。</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 调用tryAcquire()让当前线程尝试获取锁。</span></div><div class="line"><span class="comment">// 2. 如果获取不到锁：</span></div><div class="line"><span class="comment">//    调用addWaiter()构造持有当前线程的节点，该节点设置成互斥锁模式，并加入等待队列。</span></div><div class="line"><span class="comment">//    调用acquireQueued()，在等待队列里自旋。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 尝试获取锁。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 1. 如果state==0，那么通过CAS让state增1，并设置当前线程持有锁。</span></div><div class="line"><span class="comment">// 2. 当前线程已经持有锁，那么让state增1。</span></div><div class="line"><span class="comment">// 以上两种情况最终都持有锁，返回true。</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 1. 如果前继节点是head，则调用tryAcquire()尝试获取锁。</span></div><div class="line"><span class="comment">//    如果获取成功，调用setHead()把当前节点设置成head节点。（Note：因为是互斥锁，所有只在unlock()的时候唤醒阻塞的节点）</span></div><div class="line"><span class="comment">// 2. 调用shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()让节点阻塞等待。</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该方法跟非公平锁的区别：如果程序未上锁，非公平锁会尝试在此方法加锁，而公平锁会在tryAcquire()中调用hasQueuedPredecessors()询问是否有比当前线程等待时间更长的线程，倾向于让该线程加锁。</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 尝试获取锁。该方法与非公平锁一致，只是tryAcquire()方法存在差别。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该方法比非公平锁版本多了hasQueuedPredecessors()，查询是否有比当前线程等待时间更长的线程。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 比较等待队列中head节点的后继节点是否持有当前线程，以此来判断是否有更长等待时间的线程。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node t = tail;</div><div class="line">    Node h = head;</div><div class="line">    Node s;</div><div class="line">    <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="unlock-方法"><a href="#unlock-方法" class="headerlink" title="unlock()方法"></a>unlock()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用继承自AQS的内部类Sync实现。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 1. 调用tryRelease()尝试释放锁。</span></div><div class="line"><span class="comment">// 2. 如果可以释放锁，调用unparkSuccessor()唤醒等待队列的后继阻塞节点。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该方法尝试释放锁。主要做以下事情：</span></div><div class="line"><span class="comment">// 1. 如果不是当前线程持有锁，则抛出异常。</span></div><div class="line"><span class="comment">// 2. state变量减1后，如果为0，则表示可以释放锁，返回true。否则，记录state为减1状态，并返回false。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果当前节点存在后继节点，唤醒该节点对应的线程。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Condition相关的方法"><a href="#Condition相关的方法" class="headerlink" title="Condition相关的方法"></a>Condition相关的方法</h3><blockquote><p> <code>Condition.await()</code>跟<code>Object.wait()</code>功能类似，<code>Condition.signal()</code>跟<code>Object.notify()</code>功能类似。</p></blockquote><h4 id="newCondition-方法"><a href="#newCondition-方法" class="headerlink" title="newCondition()方法"></a>newCondition()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用继承自AQS的内部类Sync实现。</span></div><div class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sync.newCondition();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用AQS的内部类ConditionObject实现。</span></div><div class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Condition的await-方法"><a href="#Condition的await-方法" class="headerlink" title="Condition的await()方法"></a>Condition的<code>await()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 如果当前线程被中断，则抛出异常。</span></div><div class="line"><span class="comment">// 2. 调用addConditionWaiter()增加持有当前线程的新节点到条件等待队列。</span></div><div class="line"><span class="comment">// 3. 调用release()方法释放锁，如果释放失败，抛出异常。</span></div><div class="line"><span class="comment">// 4. 调用LockSupport.park阻塞当前线程，直到被唤醒或发生中断。</span></div><div class="line"><span class="comment">// 5. 调用特别版本的acquire()重新获取锁。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    Node node = addConditionWaiter();</div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</div><div class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">        LockSupport.park(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">        interruptMode = REINTERRUPT;</div><div class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></div><div class="line">        unlinkCancelledWaiters();</div><div class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</div><div class="line">        reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Condition的signal-方法"><a href="#Condition的signal-方法" class="headerlink" title="Condition的signal()方法"></a>Condition的<code>signal()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 如果当前线程不是持有互斥锁的线程，则抛出异常。</span></div><div class="line"><span class="comment">// 2. 调用doSignal()把条件等待队列的节点放入锁等待队列。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    Node first = firstWaiter;</div><div class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">        doSignal(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;从API层面实现互斥锁，而&lt;code&gt;synchronized&lt;/code&gt;关键字则从JVM层面来实现互斥锁。&lt;br&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;可以实现公平锁和非公平锁，而&lt;code&gt;synchronized&lt;/code&gt;只能是非公平锁。&lt;br&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;可以绑定多个Conditon。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK源码" scheme="http://nullhint.org/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>JUC.CountDownLatch实现原理</title>
    <link href="http://nullhint.org/2017/11/06/JUC_CountDownLatch/"/>
    <id>http://nullhint.org/2017/11/06/JUC_CountDownLatch/</id>
    <published>2017-11-06T15:25:00.000Z</published>
    <updated>2017-11-12T14:41:13.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p><code>CountDownLatch</code>是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。<br>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><blockquote><p><code>CountDownLatch</code>的典型用法是将一个程序分成独立的N个子任务，并创建一个值为N的<code>CountDownLatch</code>，每个子任务执行完就调用<code>countDown()</code>，等待问题被解决的任务调用这个锁的<code>await()</code>，直到所有子任务执行完才能继续往下执行。</p></blockquote><a id="more"></a><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CountDownLatch startSignal, CountDownLatch doneSignal)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.startSignal = startSignal;</div><div class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            startSignal.await();</div><div class="line">            doWork();</div><div class="line">            doneSignal.countDown();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" working...."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        doSomethingElse(); <span class="comment">// don't let run yet</span></div><div class="line">        startSignal.countDown(); <span class="comment">// let all threads proceed</span></div><div class="line">        doSomethingElse();</div><div class="line">        doneSignal.await(); <span class="comment">// wait for all to finish</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"Driver do something=="</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>运行结果</strong><blockquote><p>Driver do something==<br>Thread-0 working….<br>Thread-7 working….<br>Thread-2 working….<br>Thread-5 working….<br>Thread-4 working….<br>Thread-1 working….<br>Thread-3 working….<br>Thread-9 working….<br>Thread-6 working….<br>Thread-8 working….<br>Driver do something==</p></blockquote></li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>CountDownLatch</code>基于<code>AQS(AbstractQueuedSynchronizer，队列同步器)</code>的<strong>“共享模式”</strong>，以<code>AQS</code>的<code>int</code>类型变量<code>state</code>记录同步状态，用一个双向链表为实现的<strong>FIFO队列</strong>记录每一个阻塞等待的线程，让线程自旋等待（利用<code>LockSupport.park()</code>的线程同步原语让线程阻塞），直到countDown到0，才解除线程自旋（利用<code>LockSupport.unpark()</code>的线程同步原语唤醒线程），让所有阻塞等待的线程往下执行。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="内部同步器类"><a href="#内部同步器类" class="headerlink" title="内部同步器类"></a>内部同步器类</h3><p>以一个继承自<code>AbstractQueuedSynchronizer</code>的内部类<code>Sync</code>为类型的变量<code>sync</code>作为实现基础。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</div><div class="line"></div><div class="line">    Sync(<span class="keyword">int</span> count) &#123;</div><div class="line">        setState(count);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getState();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = getState();</div><div class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数调用时，<code>count</code>参数赋值给<code>AQS</code>的<code>private volatile int state;</code>，用来记录同步状态。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="await-方法"><a href="#await-方法" class="headerlink" title="await()方法"></a>await()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该方法调用内部类Sync为类型的sync变量实现。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该方法主要做以下事情：</span></div><div class="line"><span class="comment">// 1. 如果发生中断，则抛出异常。</span></div><div class="line"><span class="comment">// 2. 通过state变量来判断是否获得共享锁。</span></div><div class="line"><span class="comment">//    如果state==0，表示已经countDown到0了，获得共享锁，则直接退出该方法；</span></div><div class="line"><span class="comment">//    如果state&gt;0，表示获得共享锁失败，则调用doAcquireSharedInterruptibly()，进入等待队列。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 尝试获取共享锁。</span></div><div class="line"><span class="comment">// 其中，state==0，表示获取成功；state&gt;0，表示获取失败。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该方法主要做以下事情：</span></div><div class="line"><span class="comment">// 1. 调用addWaiter()方法，增加新节点到队列末端（该队列用双向链表实现），该节点持有当前线程的引用。</span></div><div class="line"><span class="comment">// 2. 让线程在for循环里自旋，如果节点的前继节点是head节点，尝试获取共享锁。</span></div><div class="line"><span class="comment">//    如果获取成功，调用tryAcquireShared()方法，把当前节点设置成head节点，并唤醒等待队列的后继节点，跳出循环，结束该方法。</span></div><div class="line"><span class="comment">// 3. 调用shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()方法让等待节点阻塞等待。</span></div><div class="line"><span class="comment">// 4. 跳出for循环后，如果获取共享锁失败，则调用cancelAcquire()方法把当前节点从等待队列中移除。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        setHeadAndPropagate(node, r);</div><div class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                        failed = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown()方法"></a>countDown()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该方法调用内部类Sync为类型的sync变量实现。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.releaseShared(<span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用tryReleaseShared()尝试释放共享锁。</span></div><div class="line"><span class="comment">// 如果成功，则调用doReleaseShared()释放锁。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 1. 如果state已经等于0，则不需要释放锁。</span></div><div class="line"><span class="comment">// 2. 通过CAS让state减1，如果state==0，则表示可以释放共享锁。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = getState();</div><div class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用unparkSuccessor()唤醒head的后继节点。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Node h = head;</div><div class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">                <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></div><div class="line">                    unparkSuccessor(h);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。&lt;br&gt;A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;的典型用法是将一个程序分成独立的N个子任务，并创建一个值为N的&lt;code&gt;CountDownLatch&lt;/code&gt;，每个子任务执行完就调用&lt;code&gt;countDown()&lt;/code&gt;，等待问题被解决的任务调用这个锁的&lt;code&gt;await()&lt;/code&gt;，直到所有子任务执行完才能继续往下执行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JDK源码" scheme="http://nullhint.org/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>建造者（生成器）模式</title>
    <link href="http://nullhint.org/2017/10/29/Java_BuilderPattern/"/>
    <id>http://nullhint.org/2017/10/29/Java_BuilderPattern/</id>
    <published>2017-10-29T11:35:00.000Z</published>
    <updated>2018-11-03T11:30:35.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>Separate the construction of a complex object from its representation so that the same construction process can create different representations.</li><li>使用建造者模式（Builder Pattern）封装一个产品的构造过程，并允许按步骤构造。</li></ul><h2 id="通用类图"><a href="#通用类图" class="headerlink" title="通用类图"></a>通用类图</h2><p><img src="https://i.loli.net/2018/11/03/5bdd86be93ba1.jpg" alt="建造者模式通用类图"></p><a id="more"></a><ul><li><p><strong>Product产品类</strong><br>通常是一个组合或继承（如模板方法模式）产生的类。</p></li><li><p><strong>Builder抽象建造者</strong><br>规范产品的组建，一般是由子类实现。</p></li><li><p><strong>ConcreteBuilder具体建造者</strong><br>实现抽象类定义的所有方法，并且返回一个组建好的对象。</p></li><li><p><strong>Director导演类</strong><br>负责安排已有模块的顺序，然后告诉Builder开始建造。<br>导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。</p></li></ul><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><h3 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 独立业务处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 设置产品的不同部分，以获得不同的产品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPart</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 建造产品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">buildProduct</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="具体建造者"><a href="#具体建造者" class="headerlink" title="具体建造者"></a>具体建造者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 产品类内的逻辑处理</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> product;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="导演类"><a href="#导演类" class="headerlink" title="导演类"></a>导演类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">new</span> ConcreteProduct();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 构建不同的产品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getAProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        builder.setPart();</div><div class="line">        <span class="keyword">return</span> builder.buildProduct();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>封装性：将一个复杂的对象的创建过程封装起来。</li><li>允许对象通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）。</li><li>向客户隐藏产品内部的表现。</li><li>产品的实现可以被替换，因为客户只看到一个抽象的接口。</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大的不同的地方，虽然同为创建类模式，但是注重点不同。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>《Head First设计模式》<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;br&gt;Separate the construction of a complex object from its representation so that the same construction process can create different representations.&lt;/li&gt;
&lt;li&gt;使用建造者模式（Builder Pattern）封装一个产品的构造过程，并允许按步骤构造。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;通用类图&quot;&gt;&lt;a href=&quot;#通用类图&quot; class=&quot;headerlink&quot; title=&quot;通用类图&quot;&gt;&lt;/a&gt;通用类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd86be93ba1.jpg&quot; alt=&quot;建造者模式通用类图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://nullhint.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="http://nullhint.org/2017/10/29/Java_TemplateMethodPattern/"/>
    <id>http://nullhint.org/2017/10/29/Java_TemplateMethodPattern/</id>
    <published>2017-10-29T09:10:00.000Z</published>
    <updated>2018-11-03T11:29:35.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。<br>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p><h2 id="通用类图"><a href="#通用类图" class="headerlink" title="通用类图"></a>通用类图</h2><p><img src="https://i.loli.net/2018/11/03/5bdd867ded711.jpg" alt="模板方法模式通用类图"></p><a id="more"></a><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        primitiveOperation1();</div><div class="line">        primitiveOperation2();</div><div class="line">        concreteOperation();</div><div class="line">        hook();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">primitiveOperation1</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 声明为final，使其无法被覆盖</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">concreteOperation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 这里是实现</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 钩子方法，不强制实现该方法</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">primitiveOperation1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"ConcreteClass1.primitiveOperation1()"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">primitiveOperation2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"ConcreteClass1.primitiveOperation2()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">primitiveOperation1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"ConcreteClass2.primitiveOperation1()"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">primitiveOperation2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"ConcreteClass2.primitiveOperation2()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="场景类"><a href="#场景类" class="headerlink" title="场景类"></a>场景类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        AbstractClass class1 = <span class="keyword">new</span> ConcreteClass1();</div><div class="line">        AbstractClass class2 = <span class="keyword">new</span> ConcreteClass2();</div><div class="line">        <span class="comment">// 调用模板方法</span></div><div class="line">        class1.templateMethod();</div><div class="line">        class2.templateMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><blockquote><p>ConcreteClass1.primitiveOperation1()<br>ConcreteClass1.primitiveOperation2()<br>ConcreteClass2.primitiveOperation1()<br>ConcreteClass2.primitiveOperation2()</p></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>策略模式和模板方法模式都封装算法，一个用组合，一个用<strong>继承</strong>。</li><li>工厂方法是模板方法的一种特殊版本。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>《设计模式之禅》<br>《Head First设计模式》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。&lt;br&gt;Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.&lt;/p&gt;
&lt;h2 id=&quot;通用类图&quot;&gt;&lt;a href=&quot;#通用类图&quot; class=&quot;headerlink&quot; title=&quot;通用类图&quot;&gt;&lt;/a&gt;通用类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd867ded711.jpg&quot; alt=&quot;模板方法模式通用类图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://nullhint.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式概述</title>
    <link href="http://nullhint.org/2017/10/28/Java_DesignPattern/"/>
    <id>http://nullhint.org/2017/10/28/Java_DesignPattern/</id>
    <published>2017-10-28T11:10:00.000Z</published>
    <updated>2017-10-28T11:10:15.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p><h2 id="设计模式三大分类"><a href="#设计模式三大分类" class="headerlink" title="设计模式三大分类"></a>设计模式三大分类</h2><ul><li><p>设计模式按<strong>用途</strong>划分，可以分为以下三大类型：</p><ul><li><strong>创建型（Creational）</strong>：描述如何创建对象。</li><li><strong>结构型（Structural）</strong>：描述如何实现类或对象的组合。</li><li><strong>行为型（Behavioral）</strong>：描述类或对象怎样交互以及怎样分配职责。</li></ul></li><li><p>此外，根据某个模式主要用于处理类之间的关系还是对象之间的关系，还可以分为：<strong>类模式</strong>和<strong>对象模式</strong>。<br>我们经常把两种分类结合使用，比如单例模式是对象创建类型模式，模板方法模式是类行为模式。</p></li></ul><a id="more"></a><ul><li>23中经典设计模式分类如下：</li></ul><table><thead><tr><th style="text-align:center"><em>分类</em></th><th style="text-align:left">创建型</th><th style="text-align:left">结构型</th><th style="text-align:left">行为型</th></tr></thead><tbody><tr><td style="text-align:center"><strong>类</strong></td><td style="text-align:left">Factory Method（工厂方法）</td><td style="text-align:left">Adapter_Class（适配器类）</td><td style="text-align:left">Interpreter（解释器）<br> Template Method（模板方法）</td></tr><tr><td style="text-align:center"><strong>对象</strong></td><td style="text-align:left">Abstract Factory（抽象工厂）  <br> Builder（生成器）  <br> Prototype（原型）  <br> Singleton（单例）</td><td style="text-align:left">Adapter_Object（适配器对象） <br> Bridge（桥接） <br> Composite（组合） <br> Decorator（装饰） <br> Facade（外观） <br> Flyweight（享元） <br> Proxy（代理）</td><td style="text-align:left">Chain of Responsibility（职责链） <br> Command（命令） <br> Iterator（迭代器） <br> Mediator（中介者） <br> Memento（备忘录） <br> Observer（观察者） <br> State（状态） <br> Strategy（策略） <br> Visitor（访问者模式）</td></tr></tbody></table><!--more--><h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>设计模式六大原则分别为：</p><ul><li><strong>单一职责原则（S）</strong>：Single Responsibility Principle，SRP。</li><li><strong>里氏替换原则（L）</strong>：Liskov Substitution Principle，LSP。</li><li><strong>依赖倒置原则（D）</strong>：Dependence Inversion Principle，DIP。</li><li><strong>接口隔离原则（I）</strong>：Interface Segregation Principle。</li><li><strong>迪米特法则（L）</strong>：Law of Demeter，LoD，也称为最少知识原则（Least Knowledge Principle, LKP）。</li><li><strong>开闭原则（O）</strong>：Open Closed Principle。</li></ul></li><li><p>六个设计原则关系<br>6个设计原则首字母联合起来就是<strong>SOLID</strong>（稳定的），其代表的含义也就是把这6个原则结合使用的好处：建立稳定灵活、健壮的设计，而<strong>开闭原则</strong>又是重中之重，是最基础的原则，是其他五大原则的精神领袖。</p></li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>应该有且仅有一个原因引起类的变更（There  should never be more than one reason for a class to change ）。</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ol><li>类的复杂性降低。</li><li>可读性提高。</li><li>可维护性提高。</li><li>变更引起的风险降低。</li></ol><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><p>职责的划分。</p><h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><p>类、接口和方法（一个方法尽可能做一件事）。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul><li><p>第一种定义（最正宗）：</p><blockquote><p>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）</p></blockquote></li><li><p>第二种定义（最清晰明确）：</p><blockquote><p>Function that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p></blockquote></li><li><p>该原则包含了以下4层含义：</p><blockquote><ol><li>子类必须完全实现父类的方法。</li><li>子类可以有自己的个性。</li><li>覆盖或实现父类的方法时输入参数可以被放大。</li><li>覆写或实现父类的方法时输出结果可以被缩小。</li></ol></blockquote></li></ul><h4 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>在项目中，采用里氏替换原则时，尽量避免子类的“个性”。</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>High level modules should not depend upon low level modules. Both should depend upon abstraction. Abstraction should not depend upon details. Details should depend upon abstractions.</li><li>更精简的定义：面向接口编程。</li></ul><h4 id="在Java语言中的表现"><a href="#在Java语言中的表现" class="headerlink" title="在Java语言中的表现"></a>在Java语言中的表现</h4><ol><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系式通过接口或抽象类产生的。</li><li>接口或抽象类不依赖于实现类。</li><li>实现类依赖接口或抽象类。</li></ol><h4 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol><li>每个类都有接口或抽象类，或者抽象类和接口两者都具备。</li><li>变量的表面类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>尽量不要覆写基类的方法。</li><li>结合里氏替换原则适用。</li></ol><blockquote><p><strong>何为“倒置”</strong>：<br>依赖正置就是类间的依赖是实实在在地实现类间的依赖，也就是面向实现编程。我要使用笔记本，就直接依赖笔记本。而编写程序需要的是对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维的事物间的依赖。</p></blockquote><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><ul><li><p>一种定义</p><blockquote><p>Clients should not be forced to depend upon interfaces that they don’t use.（客户端不应该依赖它不需要的接口） </p></blockquote></li><li><p>另一种定义</p><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上）</p></blockquote></li></ul><h4 id="与单一职责原则区别"><a href="#与单一职责原则区别" class="headerlink" title="与单一职责原则区别"></a>与单一职责原则区别</h4><p>接口隔离原则与单一职责原则的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。</p><h4 id="最佳实践-3"><a href="#最佳实践-3" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>一个接口只服务于一个子模块或业务逻辑。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>一个对象应该对其他对象有最少的了解。</p><blockquote><p>包含了四层含义：</p><ol><li>只和朋友交流。</li><li>朋友间也是有距离的。</li><li>是自己的就是自己的。</li><li>谨慎使用Serializable。</li></ol></blockquote><h4 id="最佳实践-4"><a href="#最佳实践-4" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>Software entities like classes, modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭）</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。&lt;/p&gt;
&lt;h2 id=&quot;设计模式三大分类&quot;&gt;&lt;a href=&quot;#设计模式三大分类&quot; class=&quot;headerlink&quot; title=&quot;设计模式三大分类&quot;&gt;&lt;/a&gt;设计模式三大分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计模式按&lt;strong&gt;用途&lt;/strong&gt;划分，可以分为以下三大类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建型（Creational）&lt;/strong&gt;：描述如何创建对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结构型（Structural）&lt;/strong&gt;：描述如何实现类或对象的组合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行为型（Behavioral）&lt;/strong&gt;：描述类或对象怎样交互以及怎样分配职责。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;此外，根据某个模式主要用于处理类之间的关系还是对象之间的关系，还可以分为：&lt;strong&gt;类模式&lt;/strong&gt;和&lt;strong&gt;对象模式&lt;/strong&gt;。&lt;br&gt;我们经常把两种分类结合使用，比如单例模式是对象创建类型模式，模板方法模式是类行为模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://nullhint.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal和InheritableThreadLocal实现原理</title>
    <link href="http://nullhint.org/2017/10/28/Java_ThreadLocal/"/>
    <id>http://nullhint.org/2017/10/28/Java_ThreadLocal/</id>
    <published>2017-10-28T04:10:00.000Z</published>
    <updated>2017-10-28T04:08:55.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>类<code>Threadlocal</code>主要解决的是每个线程绑定自己的值，可以将<code>ThreadLocal</code>类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。<br>子线程和父线程各有各自所拥有的值。</p><a id="more"></a><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                Tools.threadLocal.set(<span class="string">"ThreadA"</span> + (i + <span class="number">1</span>));</div><div class="line">                System.out.println(<span class="string">"ThreadA get Value="</span> + Tools.threadLocal.get());</div><div class="line">                Thread.sleep(<span class="number">200</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                Tools.threadLocal.set(<span class="string">"ThreadB"</span> + (i + <span class="number">1</span>));</div><div class="line">                System.out.println(<span class="string">"ThreadB get Value="</span> + Tools.threadLocal.get());</div><div class="line">                Thread.sleep(<span class="number">200</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ThreadA a = <span class="keyword">new</span> ThreadA();</div><div class="line">            ThreadB b = <span class="keyword">new</span> ThreadB();</div><div class="line">            a.start();</div><div class="line">            b.start();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                Tools.threadLocal.set(<span class="string">"Main"</span> + (i + <span class="number">1</span>));</div><div class="line">                System.out.println(<span class="string">"Main get Value="</span> + Tools.threadLocal.get());</div><div class="line">                Thread.sleep(<span class="number">200</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>输出结果如下：</strong><blockquote><p>……<br>ThreadA get Value=ThreadA95<br>ThreadB get Value=ThreadB95<br>Main get Value=Main95<br>ThreadA get Value=ThreadA96<br>ThreadB get Value=ThreadB96<br>Main get Value=Main96<br>ThreadA get Value=ThreadA97<br>ThreadB get Value=ThreadB97<br>Main get Value=Main97<br>ThreadA get Value=ThreadA98<br>ThreadB get Value=ThreadB98<br>Main get Value=Main98<br>ThreadA get Value=ThreadA99<br>ThreadB get Value=ThreadB99<br>Main get Value=Main99<br>ThreadA get Value=ThreadA100<br>ThreadB get Value=ThreadB100<br>Main get Value=Main100</p></blockquote></li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>通过每个线程对象<code>java.lang.Thread</code>的<code>ThreadLocal.ThreadLocalMap</code>成员变量来保存线程私有的数据副本，<code>ThreadLocal.ThreadLocalMap</code>是一种hash map，其内部通过一个数组来保存数据，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">// ......</span></div><div class="line"> </div><div class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained by the ThreadLocal class. */</span></div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// ......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ThreadLocal的set-方法"><a href="#ThreadLocal的set-方法" class="headerlink" title="ThreadLocal的set()方法"></a>ThreadLocal的set()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1.获取当前线程</span></div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        <span class="comment">// 2.获取当前线程对应的ThreadLocalMap成员变量</span></div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="comment">// 3.ThreadLocalMap成员变量不为空则往该hash map设值，其中ThreadLocal作为key值</span></div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="comment">// 4.ThreadLocalMap成员变量不存在则创建该map</span></div><div class="line">            createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>关键点：</strong></p><blockquote><ul><li><code>ThreadLocal</code>的静态内部类<code>ThreadLocalMap</code>作为存储数据的数据结构，其内部是一个以数组为实现方式的hash map。</li><li><code>ThreadLocalMap</code>根据<code>ThreadLocal</code>对象本身来计算hash map中的key，而key的hashCode是通过<code>ThreadLocal</code>类的静态原子变量<code>nextHashCode</code>来实现。</li></ul></blockquote><h4 id="ThreadLocal的get-方法"><a href="#ThreadLocal的get-方法" class="headerlink" title="ThreadLocal的get()方法"></a>ThreadLocal的get()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 1.获取当前线程</span></div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        <span class="comment">// 2.获取当前线程对应的ThreadLocalMap成员变量</span></div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="comment">// 3.根据`ThreadLocal`对象计算hash map中的key，获取对应的数据</span></div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> (T)e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 4.如果ThreadLocalMap尚未创建，则设置初始值，可通过覆盖initialValue()方法来自定义初始化</span></div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ThreadLocal的initialValue-方法"><a href="#ThreadLocal的initialValue-方法" class="headerlink" title="ThreadLocal的initialValue()方法"></a>ThreadLocal的initialValue()方法</h4><ul><li>通过覆写该方法来对<code>ThreadLocal</code>自定义初始化。</li><li>只有首次调用<code>get()</code>方法并且当前线程尚未创建<code>ThreadLocalMap</code>成员变量时，才会调用<code>initialValue()</code>。</li><li>如果先调用了<code>set()</code>方法，则不会调用<code>initialValue()</code>。</li></ul><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>使用类<code>InheritableThreadLocal</code>可以在子线程中取得父线程继承下来的值。<br>需要注意的一点是：如果子线程在取得值的同时，主线程将<code>InheritableThreadLocal</code>中的值进行更改，那么子线程取到的值还是旧值。</p><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Date()).getTime();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InheritableThreadLocalExt threadLocal = <span class="keyword">new</span> InheritableThreadLocalExt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                System.out.println(<span class="string">"在ThreadA线程中取值="</span> + Tools.threadLocal.get());</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                System.out.println(<span class="string">"   在Main线程中取值="</span> + Tools.threadLocal.get());</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125;</div><div class="line">            Thread.sleep(<span class="number">5000</span>);</div><div class="line">            <span class="keyword">new</span> ThreadA().start();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>输出结果如下：</strong><blockquote><p>  在Main线程中取值=1508762101600<br>  在Main线程中取值=1508762101600<br>  在Main线程中取值=1508762101600<br>  在Main线程中取值=1508762101600<br>  在Main线程中取值=1508762101600<br>  在Main线程中取值=1508762101600<br>  在Main线程中取值=1508762101600<br>  在Main线程中取值=1508762101600<br>  在Main线程中取值=1508762101600<br>  在Main线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600<br>在ThreadA线程中取值=1508762101600</p></blockquote></li></ul><h3 id="值继承再修改"><a href="#值继承再修改" class="headerlink" title="值继承再修改"></a>值继承再修改</h3><blockquote><p>在继承父线程的值的同时，对值进行进一步的处理。</p></blockquote><ul><li><strong>更改类<code>InheritableThreadLocalExt</code>代码如下：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Date()).getTime();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">childValue</span><span class="params">(Object parentValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> parentValue + <span class="string">"  我在子线程加的~！"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>输出结果如下：</strong><blockquote><p>   在Main线程中取值=1508762297039<br>   在Main线程中取值=1508762297039<br>   在Main线程中取值=1508762297039<br>   在Main线程中取值=1508762297039<br>   在Main线程中取值=1508762297039<br>   在Main线程中取值=1508762297039<br>   在Main线程中取值=1508762297039<br>   在Main线程中取值=1508762297039<br>   在Main线程中取值=1508762297039<br>   在Main线程中取值=1508762297039<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！<br>在ThreadA线程中取值=1508762297039  我在子线程加的~！</p></blockquote></li></ul><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li><code>InheritableThreadLocal</code>继承自<code>ThreadLocal</code>，通过<code>Thread</code>类的<code>ThreadLocal.ThreadLocalMap</code>类型成员变量<code>inheritableThreadLocals</code>在父子线程中传递值，并通过覆写<code>getMap()</code>和<code>createMap()</code>把<code>Thread</code>中的<code>threadLocals</code>替换成<code>inheritableThreadLocals</code>。<br>参照以上的例子，实现原理大致如下：</li></ul><ol><li>调用<code>main()</code>方法时创建main线程。此时，<code>inheritableThreadLocals</code>为null。</li><li><code>main()</code>方法通过<code>InheritableThreadLocalExt.get()</code>方法，在内部调用<code>InheritableThreadLocalExt.initialValue()</code>给main线程的<code>inheritableThreadLocals</code>成员变量赋初始值1508762297039。</li><li>在main()方法中通过<code>new ThreadA();</code>创建子线程，此时<code>Thread</code>类的默认构造函数调用<code>init()</code>方法，给子线程的<code>inheritableThreadLocals</code>成员变量赋上main父线程的值。代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></div><div class="line"><span class="function"><span class="params">                   <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</div><div class="line">     <span class="comment">// ...</span></div><div class="line"> </div><div class="line">     <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</div><div class="line">         <span class="keyword">this</span>.inheritableThreadLocals =</div><div class="line">             ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</div><div class="line">     </div><div class="line">     <span class="comment">// ...</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>《Java多线程编程核心技术》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;类&lt;code&gt;Threadlocal&lt;/code&gt;主要解决的是每个线程绑定自己的值，可以将&lt;code&gt;ThreadLocal&lt;/code&gt;类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。&lt;br&gt;子线程和父线程各有各自所拥有的值。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK源码" scheme="http://nullhint.org/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Java工厂模式实现方式</title>
    <link href="http://nullhint.org/2017/10/22/Java_FactoryPattern/"/>
    <id>http://nullhint.org/2017/10/22/Java_FactoryPattern/</id>
    <published>2017-10-22T05:15:00.000Z</published>
    <updated>2018-11-03T11:27:59.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>所有工厂模式都用来封装对象的创建，工厂模式又分为工厂方法模式和抽象工厂模式，抽象工厂模式是工厂方法模式的升级版本。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。<br>(Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.)</p></blockquote><h3 id="通用类图"><a href="#通用类图" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://i.loli.net/2018/11/03/5bdd85ecb727a.jpg" alt="工厂方法模式通用类图"></p><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><blockquote><p><code>Creator</code>实现了所有操纵产品的方法，但定义成抽象的工厂方法<code>factoryMethod()</code>由子类实现。<br>所有产品实现共同的接口<code>Product</code>，这样一来，使用这些产品的类就可以引用这个接口，而不是具体类。<br><code>ConcreteCreator</code>负责创建具体产品。</p></blockquote><a id="more"></a><h3 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h3><h4 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 产品抽象类。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 产品类的公共方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 抽象方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 产品实现类之一。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 抽象工厂类。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建一个产品对象，其输入参数类型可以自行设置，通常为String、Enum、Class等，当然也可以为空。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> c   具体产品类型</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 具体产品类</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 产品对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 具体工厂类。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</div><div class="line">        Product product = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            product = (Product) Class.forName(c.getName()).newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">// 异常处理</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (T) product;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="场景类"><a href="#场景类" class="headerlink" title="场景类"></a>场景类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 场景类。</div><div class="line"> */</div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Creator creator = new ConcreteCreator();</div><div class="line">        ConcreteProduct1 product = creator.createProduct(ConcreteProduct1.class);</div><div class="line"></div><div class="line">        // 继续业务处理</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong>抽象工厂模式</strong>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。<br>(Provide an interface for creating families of related or dependent objects without specifying their concrete classes.)</p></blockquote><h3 id="通用类图-1"><a href="#通用类图-1" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="https://i.loli.net/2018/11/03/5bdd85ecb8cb7.jpg" alt="抽象工厂模式通用类图"></p><h3 id="通用代码-1"><a href="#通用代码-1" class="headerlink" title="通用代码"></a>通用代码</h3><h4 id="产品类-1"><a href="#产品类-1" class="headerlink" title="产品类"></a>产品类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 抽象产品类A。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 每个产品共用的方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shareMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 每个产品相同方法，不同实现</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 抽象产品类B。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 每个产品共用的方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shareMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 每个产品相同方法，不同实现</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 产品A1的实现类。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"产品A1的实现方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 产品A2的实现类。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"产品A2的实现方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象产品类B的实现类.....</span></div></pre></td></tr></table></figure><h4 id="工厂类-1"><a href="#工厂类-1" class="headerlink" title="工厂类"></a>工厂类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 抽象工厂类。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCreator</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建A产品家族。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> A产品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建B产品家族。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> B产品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 产品等级1的实现类。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator1</span> <span class="keyword">extends</span> <span class="title">AbstractCreator</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 只生产产品等级为1的A产品。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 产品等级为1的A产品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 只生产产品等级为1的B产品。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 产品等级为1的B产品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 产品等级2的实现类。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator2</span> <span class="keyword">extends</span> <span class="title">AbstractCreator</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 只生产产品等级为2的A产品。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 产品等级为2的A产品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 只生产产品等级为2的B产品。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 产品等级为2的B产品</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="场景类-1"><a href="#场景类-1" class="headerlink" title="场景类"></a>场景类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 使用场景类。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义出两个工厂</span></div><div class="line">        AbstractCreator creator1 = <span class="keyword">new</span> Creator1();</div><div class="line">        AbstractCreator creator2 = <span class="keyword">new</span> Creator2();</div><div class="line"></div><div class="line">        <span class="comment">// 产生A1对象</span></div><div class="line">        AbstractProductA a1 = creator1.createProductA();</div><div class="line">        <span class="comment">// 产生A2对象</span></div><div class="line">        AbstractProductA a2 = creator2.createProductA();</div><div class="line">        <span class="comment">// 产生B1对象</span></div><div class="line">        AbstractProductB b1 = creator1.createProductB();</div><div class="line">        <span class="comment">// 产生B2对象</span></div><div class="line">        AbstractProductB b2 = creator2.createProductB();</div><div class="line"></div><div class="line">        <span class="comment">// ......</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>封装性，面向接口编程。</li><li>产品族内的约束为非公开状态。具体的产品族内的约束是在工厂内实现的。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>抽象工厂模式的最大缺点就是产品族（不是产品等级）扩展非常困难。因为要通过抽象类以及每个子类增加新的方法来实现，严重违反了开闭原则。</p><h2 id="工厂方法与抽象工厂的异同"><a href="#工厂方法与抽象工厂的异同" class="headerlink" title="工厂方法与抽象工厂的异同"></a>工厂方法与抽象工厂的异同</h2><p>抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。无论是工厂方法还是抽象工厂，都是通过子类来实现具体对象的创建，只是工厂方法针对一个产品族，抽象工厂针对的是多个相关联的产品族。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>《设计模式之禅》</li><li>《Head First设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;所有工厂模式都用来封装对象的创建，工厂模式又分为工厂方法模式和抽象工厂模式，抽象工厂模式是工厂方法模式的升级版本。&lt;/p&gt;
&lt;h2 id=&quot;工厂方法模式&quot;&gt;&lt;a href=&quot;#工厂方法模式&quot; class=&quot;headerlink&quot; title=&quot;工厂方法模式&quot;&gt;&lt;/a&gt;工厂方法模式&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。&lt;br&gt;(Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;通用类图&quot;&gt;&lt;a href=&quot;#通用类图&quot; class=&quot;headerlink&quot; title=&quot;通用类图&quot;&gt;&lt;/a&gt;通用类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd85ecb727a.jpg&quot; alt=&quot;工厂方法模式通用类图&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Creator&lt;/code&gt;实现了所有操纵产品的方法，但定义成抽象的工厂方法&lt;code&gt;factoryMethod()&lt;/code&gt;由子类实现。&lt;br&gt;所有产品实现共同的接口&lt;code&gt;Product&lt;/code&gt;，这样一来，使用这些产品的类就可以引用这个接口，而不是具体类。&lt;br&gt;&lt;code&gt;ConcreteCreator&lt;/code&gt;负责创建具体产品。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://nullhint.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java单例模式实现方式</title>
    <link href="http://nullhint.org/2017/10/12/Java_Singleton/"/>
    <id>http://nullhint.org/2017/10/12/Java_Singleton/</id>
    <published>2017-10-12T13:00:00.000Z</published>
    <updated>2017-10-12T12:22:20.703Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>立即加载/“饿汉模式”：</strong>使用类的时候已经创建对象实例。<br><strong>延迟加载/“懒汉模式”：</strong>对象实例的创建延迟到方法调用时。</p></blockquote><h2 id="使用DCL（Double-Check-Locking）双检查锁机制实现单例模式"><a href="#使用DCL（Double-Check-Locking）双检查锁机制实现单例模式" class="headerlink" title="使用DCL（Double-Check Locking）双检查锁机制实现单例模式"></a>使用DCL（Double-Check Locking）双检查锁机制实现单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定义私有构造器防止被外部实例化。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Note：注意需要使用volatile。</span></div><div class="line">    <span class="comment">// 另外，JDK1.5之前无法安全地使用DCL的原因是volatile屏蔽指令重排序的语义在JDK1.5中才被完全修复。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</div><div class="line">                    singleton = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h2 id="使用静态内部类实现单例模式"><a href="#使用静态内部类实现单例模式" class="headerlink" title="使用静态内部类实现单例模式"></a>使用静态内部类实现单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="comment">// 限制产生多个对象</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHandle</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHandle.singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="使用static类变量实现单例模式"><a href="#使用static类变量实现单例模式" class="headerlink" title="使用static类变量实现单例模式"></a>使用static类变量实现单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="comment">// 限制产生多个对象</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="使用static代码块实现单例模式"><a href="#使用static代码块实现单例模式" class="headerlink" title="使用static代码块实现单例模式"></a>使用static代码块实现单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="使用enum枚举类型实现单例模式"><a href="#使用enum枚举类型实现单例模式" class="headerlink" title="使用enum枚举类型实现单例模式"></a>使用enum枚举类型实现单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> MyEnum &#123;</div><div class="line">        SINGLE;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">MyEnum</span><span class="params">()</span> </span>&#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> singleton;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> MyEnum.SINGLE.getSingleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="序列化与反序列化的单例模式实现"><a href="#序列化与反序列化的单例模式实现" class="headerlink" title="序列化与反序列化的单例模式实现"></a>序列化与反序列化的单例模式实现</h2><p>注意增加了<code>readResolve</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 内部类方式实现单例模式</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHandle</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHandle.singleton;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 反序列化时，这个方法会紧挨着readObject()之后被调用，该方法的返回值将会代替原来反序列化的对象，而原来readObject()反序列化的对象将被丢弃</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHandle.singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 序列化</span></div><div class="line">        Singleton singleton = Singleton.getInstance();</div><div class="line">        <span class="keyword">try</span> (ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"singleton.txt"</span>)))) &#123;</div><div class="line">            outputStream.writeObject(singleton);</div><div class="line">            System.out.println(singleton.hashCode());</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 反序列化</span></div><div class="line">        <span class="keyword">try</span> (ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"singleton.txt"</span>)))) &#123;</div><div class="line">            Singleton mySingleton = (Singleton) inputStream.readObject();</div><div class="line">            System.out.println(mySingleton.hashCode());</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;立即加载/“饿汉模式”：&lt;/strong&gt;使用类的时候已经创建对象实例。&lt;br&gt;&lt;strong&gt;延迟加载/“懒汉模式”：&lt;/strong&gt;对象实例的创建延迟到方法调用时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用DCL（Double-Check-Locking）双检查锁机制实现单例模式&quot;&gt;&lt;a href=&quot;#使用DCL（Double-Check-Locking）双检查锁机制实现单例模式&quot; class=&quot;headerlink&quot; title=&quot;使用DCL（Double-Check Locking）双检查锁机制实现单例模式&quot;&gt;&lt;/a&gt;使用DCL（Double-Check Locking）双检查锁机制实现单例模式&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 定义私有构造器防止被外部实例化。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Note：注意需要使用volatile。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 另外，JDK1.5之前无法安全地使用DCL的原因是volatile屏蔽指令重排序的语义在JDK1.5中才被完全修复。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton singleton;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; == singleton) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (Singleton.class) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; == singleton) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    singleton = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; singleton;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://nullhint.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
